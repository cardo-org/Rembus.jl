var documenterSearchIndex = {"docs":
[{"location":"api/#Rembus-API","page":"Component API","title":"Rembus API","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"This API provides both approaches to connection handling:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"automatic reconnection in case of network failures\nexception throwing in case of network errors and reconnection explicitly managed by the application.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Rembus API functions:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"component\nconnect\nexpose\nunexpose\nrpc\nsubscribe\nunsubscribe\npublish\nreactive\nunreactive\nwait\ninject\nclose\nshutdown","category":"page"},{"location":"api/#component","page":"Component API","title":"component","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"component(\n    url::AbstractString;\n    ws=nothing,\n    tcp=nothing,\n    zmq=nothing,\n    name=missing,\n    secure=false,\n    authenticated=false,\n    policy=\"first_up\",\n    failovers=[]\n) -> Twin\n\n# for more details\nhelp?> component","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Start a component and join the network of Rembus nodes.","category":"page"},{"location":"api/#Connected-Component","page":"Component API","title":"Connected Component","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = component(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Connect to a broker that listens at the connection point ws://hostname:8000 and return the rb handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"In case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"See Component for URL format details.","category":"page"},{"location":"api/#Broker","page":"Component API","title":"Broker","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = component(ws=8000, tcp=8001)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Start a broker that listens on the web socket port 8000 and on the TCP port 8001. The broker will accept connections from other components.","category":"page"},{"location":"api/#Broker-and-Connected-Component","page":"Component API","title":"Broker and Connected Component","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"This is an advanced pattern that allows to create a component that is also a broker and that is able to connect to another broker. This pattern is useful for creating a component that is able to act as a proxy between two brokers or to create a component that is able to connect to a broker and at the same time to act as a broker for other components.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = component(\"ws://hostname:8000/mycomponent\", ws=9000)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Start a broker that listens on the WebSocket port 9000 and connect to a broker defined at the connection point ws://hostname:8000.","category":"page"},{"location":"api/#connect","page":"Component API","title":"connect","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"connect(url::AbstractString) -> Twin","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Connect to the broker and return a connection handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The URL string passed to connect contains the address of a broker, the transport protocol, the port and optionally a persistent unique name for the component.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"A disconnection from the remote endpoint will not trigger automatic reconnection, for example:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Connects to a broker that listens at the connection point ws://hostname:8000 and returns the rb handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the broker is not reachable the connect function will throw an Exception and if the connection is lost at a later time the rb handle becomes disconnected. The status of a component can be checked with the isopen  method:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"isopen(rb)","category":"page"},{"location":"api/#expose","page":"Component API","title":"expose","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"expose(rb, name::AbstractString, fn::Function)\nexpose(rb, fn::Function)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\nexpose(rb, myservice)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The exposed function will became available to RPC clients using the @rpc macro or the rpc function.","category":"page"},{"location":"api/#unexpose","page":"Component API","title":"unexpose","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"unexpose(rb, topic::AbstractString)\nunexpose(rb, fn::Function)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop serving remote requests via rpc or @rpc.","category":"page"},{"location":"api/#rpc","page":"Component API","title":"rpc","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"rpc(\n    rb::Twin,\n    service::AbstractString,\n    data...\n)\n\n# for more details\nhelp?> rpc","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"response = rpc(rb, \"my_service\", Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The service name and the arguments are CBOR-encoded and transported to the remote site and the method my_service that expects a Dict as argument is called.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The return value of my_service is transported back to the RPC client calling site and taken as the return value of rpc.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the remote method throws an Exception then the local RPC client will throw either an Exception reporting the reason of the remote error.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the exposed method expects many arguments send an array of values, where each value is an argument:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"# exposer side\nfunction my_service(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\n    return x+y+z\nend\n\n# rpc client side\nrpc(rb, \"my_service\", [1, 2, 3])","category":"page"},{"location":"api/#subscribe","page":"Component API","title":"subscribe","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"subscribe(rb, topic::AbstractString, fn::Function, from=Rembus.Now)\n\nsubscribe(rb, fn::Function, from=Rembus.Now)\n\n# for more details\nhelp?> subscribe","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Declare interest for messages published on the topic logical channel.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the topic is not specified the function fn is subscribed to the topic of the same name of the function.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"To enable the reception of published messages, reactive must be called.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\nrb = connect()\n\nsubscribe(rb, mytopic)\n\nreactive(rb) ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"By default subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interTYPEDSIGNATURESest in old messages with the from argument set to LastReceived:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect(\"myname\")\n\nsubscribe(rb, mytopic, LastReceived)\n\nreactive(rb) ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The subscribed function will be called each time a component produce a message with the@publish macro or the publish function.","category":"page"},{"location":"api/#unsubscribe","page":"Component API","title":"unsubscribe","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"unsubscribe(rb::Twin, topic::AbstractString)\nunsubscribe(rb::Twin, fn::Function)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop the function to receive messages produced with publish or @publish.","category":"page"},{"location":"api/#publish","page":"Component API","title":"publish","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"publish(rb::Twin, topic::AbstractString, data...; qos=Rembus.QOS0)\n\n# for more details\nhelp?> subscribe","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Publish a message on the topic channel.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect()\n\npublish(rb, \"metric\", Dict(\"name\"=>\"trento/castello\", \"var\"=>\"T\", \"value\"=>21.0))\n\nclose(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"metric is the message topic and the Dict value is the message content.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the subscribed method expects many arguments send the values as a Vararg list:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"# subscriber side\nfunction my_topic(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\nend\n\n# publisher side\npublish(rb, \"my_topic\", 1, 2, 3)","category":"page"},{"location":"api/#reactive","page":"Component API","title":"reactive","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"reactive(\n    rb::Twin,\n    from::Union{Real,Period,Dates.CompoundPeriod}=Day(1),\n)\n\n# for more details\nhelp?> reactive","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"api/#unreactive","page":"Component API","title":"unreactive","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"unreactive(rb::Twin)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop receiving published messages.","category":"page"},{"location":"api/#wait","page":"Component API","title":"wait","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"wait(rb::Twin)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Needed for components that expose and/or subscribe  methods. Wait forever for rpc requests or pub/sub messages.","category":"page"},{"location":"api/#inject","page":"Component API","title":"inject","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"inject(rb::Twin, state::Any)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Bind a state object to the component.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"inject is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"When a state is injected two additional arguments are passed to the subscribed/exposed methods:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"the first argument is the state value;\nthe second argument is the node handle;","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The following example shows how to use a shared state:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"the struct MyState manages the state;\nthe inject method binds the state object to the component;\nthe subscribed and the exposed method must declare as first argument the state object and as second argument the node handle;","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate::MyState, handle::RBHandle, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\nrb = connect(\"ingestor\")\ninject(rb, mystate)\n\n# declare interest to messages produced with\n# publish(rb, \"add_metric\", Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\nsubscribe(rb, add_metric) \n\n# implement a service that may be requested with\n# rpc(rb, \"fetch_metrics\")\nexpose(rb, fetch_metrics)\n\nwait(rb)","category":"page"},{"location":"api/#close","page":"Component API","title":"close","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"close(rb::Twin)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Close the network connections associated with the rb handle and terminate the supervised processes related to the handle.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"close(rb)","category":"page"},{"location":"api/#shutdown","page":"Component API","title":"shutdown","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"shutdown(rb::Twin)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Terminate all the active supervised processes: The method shutdown(rb) is equivalent to close(rb).","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"","category":"page"},{"location":"cheatsheet/#Rembus-Cheat-Sheet","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/#Startup-and-teardown","page":"Rembus Cheat Sheet","title":"Startup and teardown","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Connect to the broker with identity myname:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@component \"myname\"","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Close the connection and shutdown the component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@shutdown","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Loop unless Ctrl-C or shutdown():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"wait()","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: wait is required by @subscribe and @expose unless you are in the REPL.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Terminate background Rembus task and return from wait():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"shutdown()","category":"page"},{"location":"cheatsheet/#Pub/Sub:-1-publisher-and-N-subscribers","page":"Rembus Cheat Sheet","title":"Pub/Sub: 1 publisher and N subscribers","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Publish a message with topic mytopic and data payload that is the CBOR encoding of [arg1, arg2, arg3]:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@publish mytopic(arg1, arg2, arg3)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Subscribe to topic mytopic, the arguments arg1, arg2, arg3 are the CBOR decoded values of the data payload:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"# Method `mytopic` is called for each published message.\nfunction mytopic(arg1, arg2, arg3)\n    # do something\nend\n\n# Two different modes of subscription:\n@subscribe mytopic from_now # declare interest to topic mytopic handling newer messages \n@subscribe mytopic before_now # messages from the past and not received because offline\n@subscribe mytopic # default to from_now  ","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Start and stop to call subscribed methods when a published message is received:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@reactive\n@reactive_off","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Remove the topic subscription:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unsubscribe mytopic","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"By default reactive in enabled.","category":"page"},{"location":"cheatsheet/#Remote-Procedure-Call","page":"Rembus Cheat Sheet","title":"Remote Procedure Call","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Call the remote method myrpc exposed by a component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"response = @rpc myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: in case of successfull invocation the response value is the remote method return value, othervise an exception is thrown.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Expose a method implementation:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"function myrpc(arg1, arg2)\n    # evaluate body and return response ...\n    return response\nend\n\n@expose myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Stop to serve the RPC method:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unexpose myrpc","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"page"},{"location":"http_api/#HTTP-Rest-API","page":"HTTP Rest API","title":"HTTP Rest API","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus offers an HTTP REST interface for RPC requests, Pub/Sub publishing and a set of broker administration commands.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"An HTTP endpoint must be explicity activated with the http options:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"bin/broker --http port","category":"page"},{"location":"http_api/#APIs-list","page":"HTTP Rest API","title":"APIs list","text":"","category":"section"},{"location":"http_api/#No-Auth-and-Basic-Auth-APIs","page":"HTTP Rest API","title":"No Auth and Basic Auth APIs","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET   http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/subscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/expose/{topic}/{cid}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{cid}","category":"page"},{"location":"http_api/#Basic-Auth-APIs","page":"HTTP Rest API","title":"Basic Auth APIs","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET   https://broker_host:port/admin/{command}\nPOST  https://broker_host:port/private_topic/{topic}\nPOST  https://broker_host:port/public_topic/{topic}\nPOST  https://broker_host:port/authorize/{cid}/{topic}\nPOST  https://broker_host:port/unauthorize/{cid}/{topic}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Basic-Auth is required to invoke a REST endpoint that requires client authentication:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Since Basic-Auth send the password unprotected it is strongly advised to use an encrypted https connection.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Basic-Auth POST example:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"basic_auth(str::String) = Base64.base64encode(str)\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.post(\n    \"https://127.0.0.1:9000/private_topic/my_topic\",\n    [\"Authorization\" => auth]\n)","category":"page"},{"location":"http_api/#RPC","page":"HTTP Rest API","title":"RPC","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The GET HTTP method used to make RPC requests has the following url template:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET http[s]://broker_host:port/{method_name}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"A RPC uses a GET verb because GET is used by default to request data from the server.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The return value is JSON encoded in the response body.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"For example, consider the following exposed methods by a server component:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using Rembus\n\n@expose greet(name) = \"hello $name\"\n@expose sum(x,y) = x + y","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Then the HTTP invocations by a client will be:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using HTTP\nusing JSON3\n\nsum_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/sum\", [], JSON3.write([1.0, 2.0])).body,\n    Any\n)\n\njulia_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write(\"Julia\")).body,\n    Any\n)\n\njane_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write([\"Jane\"])).body,\n    Any\n)","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The RPC GET method returns a HTTP status success 200 and the returned value in the response body if the method succeeds or a HTTP status 403 and an error description in the response body if the method fails.","category":"page"},{"location":"http_api/#Pub/Sub","page":"HTTP Rest API","title":"Pub/Sub","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The POST HTTP method used to publish a message has the following url template:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST http[s]://broker_host:port/{method_name}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The POST verb is used for Pub/Sub because by default its scope it is to send data to the server.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument, as in the case of RPC method.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The Pub/Sub POST method returns a HTTP status success 200 and an empty response body, if the method succeeds.","category":"page"},{"location":"http_api/#Subscribe-and-Expose-configuration-commands","page":"HTTP Rest API","title":"Subscribe and Expose configuration commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The REST APIS:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST  http[s]://broker_host:port/subscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/expose/{topic}/{component}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{component}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"may be used to configure in advance the \"routing\" tables of the broker, for example to to cache Pub/Sub messages for components that never connected to the broker but that in the future they will be interested to the topic messages.","category":"page"},{"location":"http_api/#Authorization-commands","page":"HTTP Rest API","title":"Authorization commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus topics come in two flawors:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"public topic accessible to all components.\nprivate topics accessible to authorized components.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The following REST commands set the privateness and authorize a component to access a private topic:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST https://broker_host:port/private_topic/{topic}\nPOST https://broker_host:port/authorize/{component}/{topic}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The HTTP header must contain a Basic-Auth property with a base64 encoded string component:password associated with a component with admin privilege.","category":"page"},{"location":"http_api/#Broker-administration-commands","page":"HTTP Rest API","title":"Broker administration commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The REST admin command set broker properties or return the broker configuration.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET https://broker_host:port/admin/{command}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The following administrations command may be invoked:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"broker_config: return the components list that expose methods and subscribe to topics.\nenable_debug: set the broker log level to DEBUG.\ndisable_debug: disable the DEBUG log level.\nload_config: reload the broker config files from disk.\nsave_config: save the broker configuration to disk.\nshutdown: shutdown the broker.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"For example the following set the broker log level to debug:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using Base64\nusing HTTP\n\nbasic_auth(str::String) = Base64.base64encode(str)\n\nadmin = \"admin\"\npassword = \"aaa\"\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.get(\n    \"http://127.0.0.1:9000/admin/enable_debug\",\n    [\"Authorization\" => auth]\n)","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"","category":"page"},{"location":"security/#Security","page":"Security","title":"Security","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"End-to-end encryption is provided by Secure Web Socket (wss) and Transport Layer Security (tls) protocols.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"Authentication and authorization are realized by using RSA keys. The component owns a secret key and the broker knows its public key.","category":"page"},{"location":"security/#End-to-end-encryption","page":"Security","title":"End-to-end encryption","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"The broker requires that in the directoy $REMBUS_KEYSTORE there are:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The server certificate rembus.crt;\nThe private key rembus.key;","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component requires a CA bundle or the CA certificate of the authority that signed the broker certificate. The environment variable HTTP_CA_BUNDLE may be used to specify the the CA file.","category":"page"},{"location":"security/#Authentication","page":"Security","title":"Authentication","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"For enabling authentication a previsous exchange of a public key or a shared secret must be performed.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the secret material is not know to the broker then the connection phase skips the authentication steps and the named component connects but without any privilege reserved to authenticated and authorized components.  ","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"For a component with name foobar that connect to the broker the authentication mechanism involves the following steps.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component sends a message declaring the name foobar;\nIf exists the file $BROKER_DB/keys/foobar then the broker replies with a random challenge;\nThe component calculates a digest, if the the $HOME/.config/rembus/keys/foobar file is a RSA private key:\nMake a SHA256 digest of a string containing the challenge plus the name foobar and signs the digest with the private key.\nOtherwise consider the file content as a shared secret and make a SHA256 digest of the string containing the challenge plus the shared secret.\nThe component send the digest to the broker;\nThe broker verifies the digest, if the the $HOME/.config/broker/keys/foobar file is a RSA public key:\nVerify that the received digest of string containing the challenge plus the name foobar is signed by the corresponding private key;  \nOtherwise verify that the received digest equals to the digest of the string containing the\nchallenge plus the shared secret;\nReturn SUCCESS if authentication succeed, otherwise return ERROR and close the connection.","category":"page"},{"location":"security/#Authorization","page":"Security","title":"Authorization","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"By default topics are considered public, that is accessible by all components.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the topic is declared private then only authorized components may access it with the methods:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"publish\nrpc\nexpose/unexpose\nsubscribe/unsubscribe","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The topic visibility may be changed by a component with admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"rb = connect(\"superuser\")\n\n# public -> private\nprivate_topic(rb, \"my_topic\")\n\n# private -> public\npublic_topic(rb, \"my_topic\")","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"To execute such actions the admin role must be assigned to the component superuser: its name must be present in the file $HOME/.config/broker/admins.json","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"More then one component may be assigned the admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"# admis.json\n[\"superuser\", \"foobar\"]","category":"page"},{"location":"security/#Component-registration","page":"Security","title":"Component registration","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"Authenticated components may be provisioned with the Rembus.register method.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"register(component_name, pin; tenant=nothing, scheme=SIG_RSA)","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"component_name is the name of the component;\npin is a secret PIN code;\ntenant is the name of the tenant;\nscheme may be equal to:\nSIG_RSA for RSA Encryption;\nSIG_ECDSA for Elliptic Curve Digital Signature Algorithm;","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"","category":"page"},{"location":"macro_api/#Macro-based-API","page":"Macro-based API","title":"Macro-based API","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The supervised API uses the metaprogramming features of Julia and provides an high level interface that make easy to integrate distributed components.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The goal of this API is to make easy developing robust and fault-tolerant distributed applications.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The following macros comprise the API and enable Julia to be supercharged with the capabilities of a middleware for RPC and Pub/Sub messaging:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component\n@expose\n@unexpose\n@rpc\n@subscribe\n@unsubscribe\n@publish\n@reactive\n@unreactive\n@wait\n@inject\n@wait","category":"page"},{"location":"macro_api/#component","page":"Macro-based API","title":"component","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"A component needs to know the address of a broker, the transport protocol, the port and optionally it has to declare a persistent unique name for the component.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"These settings are defined with a URL string:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"component_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"\n\n@component component_url","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<protocol> is one of:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"ws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<host> and <port> are the hostname/ip and the port of the listening broker.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<cid> is the unique name of the component. If it is not defined create an anonymous component.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For example:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"ws://broker.org:8000/myclient\"","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"defines the component myclient that communicates with the broker hosted on broker.org, listening on port 8000 and accepting web socket connections.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"NOTE Rembus is \"lazy\": declaring a component does not open a connection to the broker. The connection will be opened when first needed.","category":"page"},{"location":"macro_api/#Default-component-URL-parameters","page":"Macro-based API","title":"Default component URL parameters","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The URL string may be simplified by using the enviroment variable REMBUS_BASE_URL.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Setting for example REMBUS_BASE_URL=ws://localhost:8000 the above component_url may be simplified as:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"myclient\"","category":"page"},{"location":"macro_api/#expose","page":"Macro-based API","title":"expose","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\n@expose myservice","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The exposed function will became available to RPC clients using the @rpc macro.","category":"page"},{"location":"macro_api/#unexpose","page":"Macro-based API","title":"unexpose","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop serving remote requests with @rpc requests.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unexpose myservice","category":"page"},{"location":"macro_api/#rpc","page":"Macro-based API","title":"rpc","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"response = @rpc myservice(Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The arguments of the local function call myservice is transported to the remote site and myservice method expecting a Dict as argument is executed. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The return value of myservice is transported back to the RPC client calling site and @rpc returns.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"If the remote method throws an Exception then the local RPC client throws an Exception reporting the reason of the remote error.","category":"page"},{"location":"macro_api/#subscribe","page":"Macro-based API","title":"subscribe","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Declare interest for messages published on a logical channel that usually is called topic.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\n@subscribe mytopic\n\nwait() # or until Ctrl-C ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default @subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the option before_now:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"myname\"\n\n@subscribe mytopic before_now\n\n@wait # or until Ctrl-C","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"macro_api/#unsubscribe","page":"Macro-based API","title":"unsubscribe","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop the function to receive messages produced with @publish.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unsubscribe myservice","category":"page"},{"location":"macro_api/#publish","page":"Macro-based API","title":"publish","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Publishing a message is like calling a local function named as the pub/sub topic. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@publish mytopic(1.2, 3.0)","category":"page"},{"location":"macro_api/#reactive","page":"Macro-based API","title":"reactive","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@reactive","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default a component starts with reactive mode enabled.","category":"page"},{"location":"macro_api/#unreactive","page":"Macro-based API","title":"unreactive","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop receiving published messages.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unreactive","category":"page"},{"location":"macro_api/#wait","page":"Macro-based API","title":"wait","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Needed for components that expose and/or subscribe methods. Wait forever for rpc requests or pub/sub messages.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default @wait enable component reactiveness, see @reactive.","category":"page"},{"location":"macro_api/#inject","page":"Macro-based API","title":"inject","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@inject is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"When a state is injected two additional arguments are passed to the subscribed/exposed methods:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"the first argument is the state value;\nthe second argument is the node handle;","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The following example shows how to use a inject state:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"the struct MyState manages the state;\nthe @inject macro binds the state object to the component;\nthe subscribed and the exposed method must declare as first argument the state object and as second argument the node handle;","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate::MyState, rb::RBHandle, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\n@component \"ingestor\"\n@inject mystate\n\n# declare interest to messages produced with\n# @publish add_metric(Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\n@subscribe add_metric \n\n# implement a service that may be requested with\n# @rpc fetch_metrics()\n@expose fetch_metrics\n\n@wait","category":"page"},{"location":"macro_api/#wait-2","page":"Macro-based API","title":"wait","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Close the network connection and shutdown the supervised process associated with the component.   ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@wait","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"","category":"page"},{"location":"brokerless/#Client-Server-architecture","page":"Client-Server","title":"Client-Server architecture","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"It is possible to use Rembus protocol to setup a simple client-server architecture without a decoupling broker.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"In this scenario one component plays the role of a server that handles RPC requests and receives messages published by others components that play the role of clients.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"NOTE Without a broker a pub/sub is a one-to-one communication pattern: components publish messages that are received by the server but they are not broadcasted to anyone else.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"Below a minimal example of a component that exposes a service and accepts connections for others components and respond only to authenticated components:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"using Rembus\n\nfunction my_service(ctx, component, x, y)\n    return x+y\nend\n\nrb = server()\nexpose(rb, my_service)\nwait(rb)\n\nstart_server()","category":"page"},{"location":"brokerless/#Detailed-description","page":"Client-Server","title":"Detailed description","text":"","category":"section"},{"location":"brokerless/#The-Server","page":"Client-Server","title":"The Server","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The component that plays the server role is initialized as:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"rb = server()","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"expose, as usual,  make methods available to RPC clients:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"expose(rb, my_service)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The signature of my_service must have a ctx value as first argument and a component value as second argument:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"function mymethod(ctx, component, x, y)\n    return x + y\nend","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The ctx argument is a global state object that is passed to the server constructor:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"mutable struct Ctx\n    # state fields\nend\n\nctx = Ctx()\n\nrb = server(ctx)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"If a global state is not needed by default ctx is set to nothing:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"rb = server()\nexpose(rb, \"my_service\")\n\n#implies that ctx is nothing:\nfunction my_function(ctx, component, x, y)\n    @assert ctx === nothing\nend","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The component object if useful for:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"serving only authenticated components;\nstoring component session state into session(component) dictionary;","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"wait is the final step: the server starts and waits for connection requests from clients:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"Rembus.wait(rb)","category":"page"},{"location":"brokerless/#The-Client","page":"Client-Server","title":"The Client","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"On the calling side the rpc method has to be invoked with two arguments:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"@rpc my_service(x,y)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"","category":"page"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/#Environment-variables","page":"Configuration","title":"Environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A component is affected by the following environment variables.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_DIR $HOME/.config/rembus data root directory\nREMBUS_BASE_URL ws://localhost:8000 Default base url when defining component with  a simple string instead of a complete url. @component \"myclient\" is equivalent to @component \"ws://localhost:8000/myclient\"\nREMBUS_TIMEOUT 5 Maximum number of seconds waiting for rpc responses\nREMBUS_ACK_TIMEOUT 5 Maximum number of seconds waiting for pub/sub ack messages\nREMBUS_CHALLENGE_TIMEOUT 5 Time interval after which the connection is closed if a challenge response is not received when connection_mode is authenticated\nREMBUS_RECONNECT_PERIOD 1 Reconnection retry period\nREMBUS_CACHE_SIZE 1000000 Max numbers of pub/sub messages cached in memory\nHTTP_CA_BUNDLE $REMBUS_DIR/ca/rembus-ca.crt CA certificate","category":"page"},{"location":"configuration/#Broker-only-environment-variables","page":"Configuration","title":"Broker only environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"When a component is a broker the setup is affected also by the REMBUS_KEYSTORE variable that define the directory where are stored the private key and the server certificate needed for wss and tls secure connections. ","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_KEYSTORE $REMBUS_DIR/keystore Directory of broker/server certificate rembus.crt and broker/server secret key rembus.key","category":"page"},{"location":"configuration/#Broker-configuration-files","page":"Configuration","title":"Broker configuration files","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The broker name determines the directory where settings and component related data are stored.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example, to set the name of the broker with the companion broker script use the optional name argument:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"broker --name my_broker","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"In the following it is assumed the default broker name for the broker: in this case the directory $REMBUS_DIR/broker contains the broker configuration data and secret materials.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cd ~/.config/rembus/broker\n> tree .\n\n.\n admins.json\n bar.acks\n keys\n  bar.rsa.pem\n  foo.ecdsa.pem\n messages\n   1345\n   345456\n   867687\n router.json\n settings.json\n tenants.json\n tenant_component.json\n topic_auth.json\n twins\n  bar.json\n  foo.json\n\n","category":"page"},{"location":"configuration/#Component-settings","page":"Configuration","title":"Component settings","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The behavoir of a component may be configured with the properties defined in the settings.json file. The values from settings.json take priority over environment variables values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The following properties are supported (in parenthesis the corresponding environment variable):","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"cache_size (REMBUS_CACHE_SIZE): max numbers of pub/sub messages cached in memory; \nconnection_mode: \"authenticated\" or \"anonymous\" for components without name or   authentication credentials;\nack_timeout (REMBUS_ACK_TIMEOUT): timeout in seconds for pub/sub ack messages;\nchallenge_timeout (REMBUS_CHALLENGE_TIMEOUT): time interval after which the connection  is closed if a challenge response is not received. This feature holds only if  connection_mode is authenticated;\nrequest_timeout (REMBUS_TIMEOUT): maximum time in seconds for waiting a rpc response; \noverwrite_connection: If true a connecting component with the same name of an  already connected component connect successfully and the already connected component is  disconnected from the broker. \nreconnect_period (REMBUS_RECONNECT_PERIOD): reconnection retry period when connection is  down;\nstacktrace: When an exception occurs the error stack trace is logged if stacktrace is  true. \nzmq_ping_interval (REMBUS_ZMQ_PING_INTERVAL): ZMQ ping interval in seconds;\nws_ping_interval (REMBUS_WS_PING_INTERVAL): WebSocket ping interval in seconds;","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"{\n    \"cache_size\": 1000000,\n    \"connection_mode\": \"anonymous\",\n    \"ack_timeout\": 2,\n    \"challenge_timeout\": 3,\n    \"request_timeout\": 5,\n    \"overwrite_connection\": false,\n    \"reconnect_period\": 1,\n    \"stacktrace\": false,\n    \"zmq_ping_interval\": 30,\n    \"ws_ping_interval\": 30\n}","category":"page"},{"location":"configuration/#Secrets-and-public-keys","page":"Configuration","title":"Secrets and public keys","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A file in the keys directory, named after the component name, contains the secret material used to authenticate the component.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"This file may contain:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"a RSA public key;\nan ECDSA public key;\na plaintext shared password string;","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"To create the RSA or ECDSA  key pairs and send the public key to the broker the register method may be employed.","category":"page"},{"location":"configuration/#Components-with-admin-privilege","page":"Configuration","title":"Components with admin privilege","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"admins.json contains the list of components that have the admin role. The element of this list are component names.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat admins.json\n[\"foo\", \"bar\"]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A component with admin privilege may change the privateness level of topics and authorize other components to bind to private topics.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"See private_topic, public_topic, authorize, unauthorize for details.","category":"page"},{"location":"configuration/#Component-configuration","page":"Configuration","title":"Component configuration","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The twins directory contains a configuration file for each component. The name of the file is equals to the component name.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"the content of the file is a JSON object with the following fields:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"exposers: the list of topics exposed by the component.\nsubscribers: a map where keys are topic names and values are the value of the  from subscribe option.\nmark: a counter value of the more recent received message.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example, the file twins/mycomponent.json is a configuration for the component mycomponent. Such component exposes the RPC service myservice and subscribes to the topic mytopic with a from value of 3600.0 seconds.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat twins/mycomponent.json\n{\n    \"exposers\":[\"myservice\"],\n    \"subscribers\":{\"mytopic\":3600.0},\n    \"mark\":1234\n}","category":"page"},{"location":"configuration/#Private-topics","page":"Configuration","title":"Private topics","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"topic_auth.json is a map with topic as keywords and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example the following file defines the topic foo as private and only the components myconsumer and myproducer are allowed to bind to it.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat topic_auth.json\n{\n    \"foo\":[\"myconsumer\",\"myproducer\"]\n}","category":"page"},{"location":"configuration/#Multi-tenancy","page":"Configuration","title":"Multi tenancy","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The multi-tenancy feature allows to register components with different identifiers (names) and to assign them to different tenants. Each tenant has its own set of components and can manage them independently.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenants.json file example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[\n    {\n        \"tenant\": \"A\",\n        \"pin\": \"482dc7eb\",\n        \"enabled\": true\n    },\n    {\n        \"tenant\": \"B\",\n        \"pin\": \"58e26283\",\n    },\n\n]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant is the tenant identifier;\npin is a secret token used for authentication. Value is 8 digits composed of numbers and the characters [a-f];\nenabled consent to disable the tenant and this does not allow to register new components. enabled is optional and if not present it defaults to true.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If the Rembus setup is single tenant then the tenants.json file must contain only the pin value to be used by register.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[{\"pin\": \"deadbeef\"}]","category":"page"},{"location":"configuration/#Components-ownership","page":"Configuration","title":"Components ownership","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant_component.json contains the mapping between the registered component and the tenant to which it belong.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant is the tenant identifier and component is the component identifier.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example if the tenant A registered the component foo then tenant_component.json will be:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[\n    {\"tenant\": \"A\",\"component\": \"foo\"}    \n]","category":"page"},{"location":"configuration/#Published-messages-database","page":"Configuration","title":"Published messages database","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"the files in messages store all the published messages received by the broker. The messages are saved periodically and at broker shutdown.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"fault_tolerance/#Fault-tolerance-features","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"section"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Beside struggling to provide a simple and lean API one of the main points of Rembus is its ability to be fault-tolerant respect to networks and application failures.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"The Macro-based API and the component method provide an automatic reconnection policy in case of network faults and try at the best to guarantee message delivery when faults happen.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"This mean that the following RPC service will run forever and it will reconnect automatically in case of network failures or broker unavailability.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"mycomponent\"\n\nfunction myservice(input::DataFrame)\n    # run your super-cool logic and get back the result\n    output_df = my_logic(input)\n    return output_df\nend\n\n@expose myservice\n\n@wait","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Fault-tolerance holds equally for publish/subscribe setups: in case of connection lost the subscriber retries to reconnect to the broker until the connection will be up again.   ","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"If the subscription use the before_now option then messages published whereas the component was offline are delivered ordered by time of publishing when the component get online again.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"consumer\"\n\nfunction mytopic(input::DataFrame)\n    # consume the dataframe posted to mytopic topic\nend\n\n@subscribe mytopic before_now\n\n@wait","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"page"},{"location":"#Rembus","page":"Home","title":"Rembus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Rembus","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Component is a Broker or a Broker is a Component? This is the question.  The Rembus rebus","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rembus is a Julia package designed for building distributed applications using both Publish/Subscribe (Pub/Sub) and Remote Procedure Call (RPC) communication patterns. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A key distinguishing feature of Rembus is its highly flexible role system, allowing a single application to act as a client, server, publisher, subscriber, and even a message broker concurrently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This unique capability enables the implementation of a wide range of distributed architectures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key Features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Support multiple transport protocol: WebSocket, TCP, and ZeroMQ.\nEfficient CBOR encoding for primitive types.\nOptimized Arrow Table Format for encodings DataFrames.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Application Roles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"An application utilizing Rembus can assume one or more of the following roles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"RPC Client (Requestor): Initiates requests for services from other components.\nRPC Server (Exposer): Provides and executes services in response to requests.\nPub/Sub Publisher: Produces and disseminates messages to interested subscribers.\nPub/Sub Subscriber: Consumes messages published on specific topics.\nBroker: Routes messages between connected components, potentially across different transport protocols.\nBroker and Component: Combines the routing capabilities of a broker with the application logic of a component.\nServer: Accepts connections from clients but does not route messages between them in the same way a broker does.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Rembus\")","category":"page"},{"location":"#Broker","page":"Home","title":"Broker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Rembus Broker acts as a central message router, facilitating communication between components. Importantly, a Broker can bridge components using different transport protocols (e.g., a ZeroMQ component can communicate with a WebSocket component).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting a basic WebSocket Broker:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Rembus\n\ncomponent() # Starts a WebSocket server listening on port 8000","category":"page"},{"location":"","page":"Home","title":"Home","text":"The connection point for this broker is ws://host:8000.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Broker can also function as a Component, connecting to another broker while simultaneously acting as a local broker:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Rembus\nrb = component(\"ws://myhost:8000/mynode\", ws=9000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, the mynode component connects to the broker at myhost:8000 and also acts as a broker, accepting WebSocket connections on port 9000 and routing messages between its connected components.","category":"page"},{"location":"#Component","page":"Home","title":"Component","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Rembus Component is a process that embodies one or more of the communication roles (Publisher, Subscriber, Requestor, Exposer). To connect to a broker, a component uses a URL with the broker's connection point and a unique component identifier:","category":"page"},{"location":"","page":"Home","title":"Home","text":"component_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where <protocol> is one of ws, wss, tcp, tls, or zmq. <host> and <port> specify the broker's address, and <cid> is the component's unique name (optional for anonymous components).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example connecting a named component:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rb = component(\"ws://host:8000/my_component\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Component can also act as a Broker:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pub = component(\"ws://host:8000/my_pub\", ws=9000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The my_pub component communicates with the broker at host:8000 and simultaneously acts as a WebSocket broker on port 9000 for other components..","category":"page"},{"location":"","page":"Home","title":"Home","text":"Types of Components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Anonymous: Assumes a random, ephemeral identity on each connection. Useful when message origin tracing isn't required, for subscribers uninterested in offline messages, and for prototyping.\nNamed: Possesses a unique, persistent name, enabling it to receive messages published while offline.\nAuthenticated: A named component with cryptographic credentials (private key or shared secret) to prove its identity, allowing access to private Pub/Sub topics and RPC methods.","category":"page"},{"location":"#Server","page":"Home","title":"Server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rembus simplifies the client-server architecture with a dedicated server API for creating components that accept client connections without acting as general-purpose message routers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rb = server(ws=9876)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A server can expose RPC services and subscribe to Pub/Sub topics (typical server roles) but can also publish messages or request RPC services from its connected clients.","category":"page"},{"location":"#A-Simple-Broker-Script","page":"Home","title":"A Simple Broker Script","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"#!/bin/bash\n#=\nSDIR=$( dirname -- \"${BASH_SOURCE[0]}\" )\nBINDIR=$( cd -- $SDIR &> /dev/null && pwd )\nexec julia -t auto --color=no -e\"include(popfirst!(ARGS))\" \\\n --project=$BINDIR/.. --startup-file=no \"${BASH_SOURCE[0]}\" \"$@\"\n=#\nusing Rembus\nRembus.brokerd()","category":"page"},{"location":"","page":"Home","title":"Home","text":"This script starts a Rembus broker with a default WebSocket server on port 8000. Use command-line arguments (e.g., ./broker -t 8001 -z 8002) to enable TCP and ZeroMQ transports.","category":"page"},{"location":"","page":"Home","title":"Home","text":"shell> ./broker\nusage: broker [-n NAME] [-x] [-s] [-a] [-p HTTP] [-m PROMETHEUS]\n              [-w WS] [-t TCP] [-z ZMQ] [-r POLICY] [-d] [-i] [-h]\n\noptional arguments:\n  -n, --name NAME       broker name (default: \"broker\")\n  -x, --reset           factory reset, clean up broker configuration\n  -s, --secure          accept wss and tls connections\n  -a, --authenticated   only authenticated components allowed\n  -p, --http HTTP       accept HTTP clients on port HTTP (type:\n                        UInt16)\n  -m, --prometheus PROMETHEUS\n                        prometheus exposer port (type: UInt16)\n  -w, --ws WS           accept WebSocket clients on port WS (type:\n                        UInt16)\n  -t, --tcp TCP         accept tcp clients on port TCP (type: UInt16)\n  -z, --zmq ZMQ         accept zmq clients on port ZMQ (type: UInt16)\n  -r, --policy POLICY   set the broker routing policy: first_up,\n                        round_robin, less_busy (default: \"first_up\")\n  -d, --debug           enable debug logs\n  -i, --info            enable info logs\n  -h, --help            show this help message and exit","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Configuration for customizing the runtime setting.  ","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Rembus]","category":"page"},{"location":"#Rembus.RembusError","page":"Home","title":"Rembus.RembusError","text":"struct RembusError <: Rembus.RembusException\n\nGeneric Rembus error.\n\nFields\n\ncode::UInt8: error code\ntopic::Union{Nothing, String}: topic name if available\nreason::Union{Nothing, String}: detailed error message\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RembusTimeout","page":"Home","title":"Rembus.RembusTimeout","text":"struct RembusTimeout{T} <: Rembus.RembusException\n\nException thrown when a response is not received before the request timeout expires.\n\nFields\n\nmsg::Any: request message\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodException","page":"Home","title":"Rembus.RpcMethodException","text":"struct RpcMethodException <: Rembus.RembusException\n\nThrown when a RPC method throws an exception.\n\nFields\n\ntopic::String: service name\nreason::String: remote exception description\n\nExample\n\nA component exposes a method that expect a string argument.\n\n@expose foo(name::AbstractString) = \"hello \" * name\n\nA RPC client invoke the method with an integer argument.\n\ntry\n    @rpc foo(1)\ncatch e\n    @error e.reason\nend\n\nThe result is an exception:\n\n Error: MethodError: no method matching foo(::UInt64)\n\n Closest candidates are:\n   foo(!Matched::AbstractString)\n    @ Main REPL[2]:1\n @ Main REPL\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodLoopback","page":"Home","title":"Rembus.RpcMethodLoopback","text":"struct RpcMethodLoopback <: Rembus.RembusException\n\nThrown when a RPC request would invoke a locally exposed method.\n\nFields\n\ntopic::String: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodNotFound","page":"Home","title":"Rembus.RpcMethodNotFound","text":"struct RpcMethodNotFound <: Rembus.RembusException\n\nException thrown from a rpc request when the called method is unknown.\n\nFields\n\ntopic::String: service name\n\nExample\n\nAn RPC Client request a method that does not exist.\n\n@rpc coolservice()\n\nThe result is an exception:\n\nERROR: Rembus.RpcMethodNotFound(\"rembus\", \"coolservice\")\nStacktrace:\n...\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodUnavailable","page":"Home","title":"Rembus.RpcMethodUnavailable","text":"struct RpcMethodUnavailable <: Rembus.RembusException\n\nThrown when a RPC method is unavailable.\n\nA method is considered unavailable when some component that exposed the method is currently disconnected from the broker.\n\nFields\n\ntopic::String: service name\n\n\n\n\n\n","category":"type"},{"location":"#Base.close-Tuple{Rembus.Twin}","page":"Home","title":"Base.close","text":"close(rb::Rembus.Twin)\n\n\nClose the connection and terminate the component.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isopen-Tuple{Rembus.Twin}","page":"Home","title":"Base.isopen","text":"isopen(rb::Rembus.Twin) -> Bool\n\n\nCheck if the component is connected to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Base.wait-Tuple{Rembus.Twin}","page":"Home","title":"Base.wait","text":"wait(rb::Rembus.Twin)\n\n\nWait for RPC requests and Pub/Sub messages.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.authorize-Tuple{Rembus.Twin, AbstractString, AbstractString}","page":"Home","title":"Rembus.authorize","text":"function authorize(rb, client::AbstractString, topic::AbstractString)\n\nAuthorize the client component to use the private topic.\n\nThe component must have the admin role for granting topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.broker","page":"Home","title":"Rembus.broker","text":"broker(; <keyword arguments>)\n\nStart a broker node and return a handle for interacting with it.\n\nThe broker acts as a central node to manage routing of RPC requests and Pub/Sub messages between nodes.\n\nIt supports multiple communication protocols (WebSocket, TCP, and ZMQ) and allows for customizable security, authentication, and routing policies.\n\nKeyword arguments\n\nname::AbstractString=\"broker\": The unique identifier for the broker supervisor process.\nws=nothing: The WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: The TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: The ZMQ Router listening port. Set to nothing to disable.\nprometheus=nothing: The Prometheus port for scraping monitoring metrics. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\npolicy::String=\"first_up\": The routing policy used when topics are served by multiple  nodes. Possible options include:\n\"first_up\": Selects the first connected node from the list of nodes exposing the RPC method.\n\"round_robin\": Distributes requests evenly across nodes in a round-robin fashion.\n\"less_busy\": Chooses the node with fewer outstanding requests.\nDefault Behavior\nIf ws, tcp, and zmq are all set to nothing, the broker will default to listening   for WebSocket connections on port 8000.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.component-Tuple{AbstractString}","page":"Home","title":"Rembus.component","text":"component(url::AbstractString; <keyword arguments>)\n\nStart a component node and return a handle for interacting with it.\n\nIn case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.\n\nThe url argument specifies the connection details for the component. For example, the URL ws://127.0.0.1:8000/foo specifies:\n\nProtocol: ws (WebSocket). Other supported protocols: wss, tcp, tls, zmq.\nAddress: 127.0.0.1 (localhost).\nPort: 8000.\nComponent Name: foo.\n\nAnonymous connections omit the path part of the URL.\n\nIf not specified, Rembus considers the above values as the default values.\n\nThis means the URL ws://127.0.0.1:8000/foo is equivalent to simply foo.\n\nAdditionally, a component may listen for incoming connections on configured ports, enabling it to act as a broker. These ports are specified using keyword arguments.\n\nKeyword Arguments\n\nname=missing: Unique string identifier for the component's supervisor process. Defaults to the path part of the url argument if missing.\nws=nothing: WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: ZMQ Router listening port. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\npolicy::String=\"first_up\": The routing policy used when topics are served by multiple  nodes. Options:\n\"first_up\": Selects the first connected node from the list of nodes exposing the RPC method.\n\"round_robin\": Distributes requests evenly across nodes in a round-robin fashion.\n\"less_busy\": Chooses the node with fewer outstanding requests.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.component-Tuple{Vector}","page":"Home","title":"Rembus.component","text":"component(urls::Vector)\n\nStart a component that connects to a pool of nodes defined by the urls array.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.connect-Tuple{AbstractString}","page":"Home","title":"Rembus.connect","text":"connect(url::AbstractString) -> Rembus.Twin\n\n\nConnect to the remote endpoint defined by url.\n\nA disconnection from the remote endpoint will not trigger automatic reconnection.\n\nExample\n\nrb = connect(\"ws://127.0.0.1:8000/mycomponent\")\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.do_connect-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.do_connect","text":"do_connect(twin::Twin)\n\nConnect to the endpoint declared with REMBUS_BASE_URL env variable.\n\nREMBUS_BASE_URL default to ws://127.0.0.1:8000\n\nA component is considered anonymous when a different and random UUID is used as component identifier each time the application connect to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.expose-Tuple{Rembus.Twin, AbstractString, Function}","page":"Home","title":"Rembus.expose","text":"expose(rb, topic::AbstractString, fn::Function)\nexpose(rb, fn::Function)\n\nExpose the methods of function fn to be executed by rpc clients using topic as RPC method name.\n\nIf the topic argument is omitted the function name equals to the RPC method name.\n\nfn returns the RPC response.\n\nExpose the methods of function fn to be invoked by RPC clients, using topic as the RPC method name.\n\nIf the topic argument is omitted, the function name is used as the RPC method name.\n\nfn is expected to return the RPC response. Any exceptions thrown by fn are caught and returned as an RPC exception.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.get_private_topics-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.get_private_topics","text":"get_private_topics(rb)\n\nReturn a dictionary mapping private topics to their lists of authorized components.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.ifdown_block-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.ifdown_block","text":"ifdown_block(rb::Rembus.Twin)\n\n\nBlock rpc and publish calls until the twin is connected to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.inject","page":"Home","title":"Rembus.inject","text":"inject(rb, ctx)\n\nBind a ctx context to the rb component.\n\nWhen a ctx context is bound, the method signatures of subscribed and exposed functions change as follows:\n\nthe first argument is the ctx context.\nthe second argument is the rb component.\nThe remaining arguments correspond to the RPC request's arguments.\n\nThe ctx is useful for maintaining local state contextualized to the rb component.\n\nExample\n\nusing Rembus\n\n# keep the number of processed messages\nmutable struct Context\n    msgcount::UInt\nend\n\nfunction topic(context::Context, rb, arg1, arg2)\n    context.msgcount += 1\n    some_logic(arg1, arg2)\nend\n\nctx = Context(0)\nrb = component(\"myname\")\nsubscribe(rb, topic)\ninject(rb, ctx)\n\nIn this example, when a message is published:\n\npublish(rb, \"topic\", arg1, arg2)\n\nThe invoked method will receive the context and component as the first two arguments:\n\nfoo(container, rb, arg2, arg2)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.isauthenticated-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.isauthenticated","text":"isauthenticated(rb)\n\nReturn true if the component is authenticated.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.private_topic-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.private_topic","text":"private_topic(rb, topic::AbstractString)\n\nSet the specified topic to private.\n\nThe component must have the admin role to change the privacy level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.public_topic-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.public_topic","text":"public_topic(rb, topic::AbstractString)\n\nSet the specified topic to public.\n\nThe component must have the admin role to change the privacy level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.publish-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.publish","text":"publish(rb, topic::AbstractString, data...; qos=Rembus.QOS0)\n\nPublish (Vararg) data values to a specified topic.\n\nEach item in data is mapped to an argument of the remote method subscribed to the topic.\n\nThe data values can be of any type. However, if the components are implemented in different languages, the values must be either DataFrames or primitive types that are CBOR-encodable (see RFC 8949) for interoperability.\n\nThe keywork argument qos defines the quality of service (QoS) for message delivery. Possible values:\n\nRembus.QOS0: (default): At most one message is delivered to the subscriber (message may be lost).\nRembus.QOS1: At least one message is delivered to the subscriber (message may be duplicated).\nRembus.QOS2: Exactly one message is delivered to the subscriber.\n\nExamples\n\nIf the subscriber is a method that expects two arguments:\n\nmytopic(x, y) = ...  # do something with x and y\n\nYou can publish a message with (Vararg) data consisting of two values:\n\nrb = component(\"myname\")\npublish(rb, \"mytopic\", 1, 2)\n\nIf the remote subscribed method has no arguments invoke publish as:\n\npublish(rb, \"mytopic\")\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.reactive","page":"Home","title":"Rembus.reactive","text":"reactive(rb, from::Union{Real,Period,Dates.CompoundPeriod}=Day(1))\n\nEnable the reception of published messages for topics to which the node is subscribed via subscribe.\n\nThe from argument specifies the starting point in time from which messages published while the component was offline will be delivered upon reconnection.\n\nThis value applies to all subscribed topics but can be overridden by the from argument in the subscribe method for a specific topic  though only to define narrower time ranges.\n\nPossible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.\n\nExample\n\nrb = component(\"myname\")\nsubscribe(rb, \"mytopic1\", Rembus.Now)\nsubscribe(rb, \"mytopic2\", Rembus.LastReceived)\nsubscribe(rb, \"mytopic3\", Hour(1))\n\nreactive(rb, Day(1))\n\nIn this example:\n\nmytopic1 will receive messages starting from now.\nmytopic2 will receive messages published within the last day, even if subscribe()    uses Rembus.LastReceived.\nmytopic3 will receive messages published within the last hour.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.register-Tuple{AbstractString, AbstractString}","page":"Home","title":"Rembus.register","text":"register(\n    cid::AbstractString,\n    pin::AbstractString;\n    tenant=Union{Nothing, AbstractString} = nothing,\n    scheme::UInt8\n)\n\nRegister the component with name cid.\n\nTo register a component a single pin or a set of tenants must be configured in the tenants.json file.\n\nThe pin shared secret is a 8 hex digits string (for example \"deedbeef\").\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout!-Tuple{Rembus.Twin, Real}","page":"Home","title":"Rembus.request_timeout!","text":"request_timeout!(rb, value::Real)\n\nSet the request timeout value for the component rb.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.request_timeout","text":"request_timeout(rb)\n\nGet the request timeout value for the component rb.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rid-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.rid","text":"rid(rb::Rembus.Twin) -> String\n\n\nReturn the identifier of the component (Rembus IDentifier).\n\nrb = component(\"ws://myhost.org:8000/myname\")\nrid(rb) === \"myname\"\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rpc-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.rpc","text":"rpc(rb, service::AbstractString, data...)\n\nMake a request for a remote service method using Vararg data values as method arguments.\n\nReturn a value or throw an error if a request timeout occurs or the remotely invoked method throws an exception.\n\nExample\n\nrb = component(\"myclient\")\n# invoke mysum(1, 2) on the remote site\nresult = rpc(rb, \"mysum\", 1, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.server-Tuple{}","page":"Home","title":"Rembus.server","text":"server(; <keyword arguments>)\n\nStart a server node and return a handle for interacting with it.\n\nThe server accepts connection from client nodes.\n\nIt supports multiple communication protocols (WebSocket, TCP, and ZMQ) and allows for customizable security and authentication.\n\nKeyword arguments\n\nname::AbstractString=\"broker\": The unique identifier for the server supervisor process.\nws=nothing: The WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: The TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: The ZMQ Router listening port. Set to nothing to disable.\nprometheus=nothing: The Prometheus port for scraping monitoring metrics. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\n\nDefault Behavior\n\nIf ws, tcp, and zmq are all set to nothing, the broker will default to listening for WebSocket connections on port 8000.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.start_broker-Tuple{Any}","page":"Home","title":"Rembus.start_broker","text":"start_broker(;\n    wait=true,\n    secure=nothing,\n    ws=nothing,\n    tcp=nothing,\n    zmq=nothing,\n    http=nothing,\n    prometheus=nothing,\n    name=\"broker\",\n    authenticated=false,\n    reset=nothing,\n    plugin=nothing,\n    context=nothing\n)\n\nStart the node.\n\nReturn immediately when wait is false, otherwise blocks until shutdown is requested.\n\nOverwrite command line arguments if args is not empty.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.subscribe","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb, fn::Function, from=Rembus.Now)\n\nSubscribe to messages published to a topic and register a callback function fn to handle incoming messages.\n\nIf the topic argument is omitted, the function name must be equal to the topic name.\n\nThe from (default=Rembus.Now) argument defines the starting point in time from which messages published while the component was offline will be sent upon reconnection. Possible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.\n\nTo enable the reception of published messages, the reactive function must be called.\n\nExample\n\nrb = component(\"myname\")\n\n# Define a callback function for the \"mytopic\" topic\nfunction mytopic(data)\n    println(\"Received: \", data)\nend\n\n# Subscribe to \"mytopic\", receiving only new messages from now\nsubscribe(rb, mytopic, from=Rembus.Now)\nreactive(rb)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.subscribe-2","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb, topic::AbstractString, fn::Function, from=Rembus.Now)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.unauthorize-Tuple{Rembus.Twin, AbstractString, AbstractString}","page":"Home","title":"Rembus.unauthorize","text":"function unauthorize(rb, client::AbstractString, topic::AbstractString)\n\nRevoke authorization to the client component for use of the private topic.\n\nThe component must have the admin role for revoking topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb, service::AbstractString)\n\nStop servicing RPC requests targeting service.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.Twin, Function}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb, fn::Function)\n\nStop servicing RPC requests targeting fn function.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unreactive-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.unreactive","text":"unreactive(rb)\n\nStops the delivery of published messages to the rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unregister-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.unregister","text":"unregister(twin)\n\nUnregister the connected component.\n\nOnly a connected and authenticated component may execute the unregister command.\n\nusing Rembus\n\ntwin = connect(\"authenticated_component\")\nRembus.unregister(twin)\nclose(twin)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb, topic::AbstractString)\n\nStops delivering messages published on the specified topic to the rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.Twin, Function}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb, fn::Function)\n\nStops delivering messages to the specified fn function.\n\n\n\n\n\n","category":"method"},{"location":"#Visor.shutdown-Tuple{Rembus.Twin}","page":"Home","title":"Visor.shutdown","text":"shutdown(rb::Rembus.Twin)\n\n\nClose the connection and terminate the component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.@component-Tuple{Any}","page":"Home","title":"Rembus.@component","text":"@component \"url\"\n\nSet the name of the component and the protocol for connecting to the broker.\n\nurl may be:\n\n\"myname\": use $REMBUS_BASE_URL for connection parameters\n\"tcp://host:port/myname\": tcp connection\n\"ws://host:port/myname\": web socket connection\n\"zmq://host:port/myname\": ZeroMQ connection\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Expr}","page":"Home","title":"Rembus.@expose","text":"@expose function fn(arg1,...)\n    ...\nend\n\nExpose the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Symbol}","page":"Home","title":"Rembus.@expose","text":"@expose fn\n\nExpose all the methods of the function fn.\n\nExample\n\nExpose the function mycalc that implements a service that may accept two numbers or a string and number:\n\nmycalc(x::Number, y::Number) = x+y\nmycalc(x::String, y::Number) = length(x)*y\n\n@expose mycalc\n\nCall mycal service using the correct types of arguments:\n\n# ok\njulia> response = @rpc mycalc(1,2)\n0x0000000000000003\n\n# ok\njulia> response = @rpc mycalc(\"hello\",2.0)\n10.0\n\nIf the RPC client call mycalc with the argument's type that do not respect the signatures of the exposed service then it throws RpcMethodException\n\njulia> response = @rpc mycalc(\"hello\",\"world\")\nERROR: RpcMethodException(\"rembus\", \"mycalc\", \"MethodError: no method matching mycalc(::String, ::String) ...\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@inject-Tuple{Any}","page":"Home","title":"Rembus.@inject","text":" @inject container\n\nBinds a container object, which is passed as the first argument to subscribed component functions.\n\nSee inject for more details.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@publish","page":"Home","title":"Rembus.@publish","text":"@publish topic(arg1,arg2,...)\n\nPublish a message to topic logic channel.\n\nThe function topic(arg1,arg2,...) will be called on each connected component subscribed to topic.\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\nSubscriber\n\nfunction foo(name, value)\n    println(\"do something with $name=$value\")\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@reactive","page":"Home","title":"Rembus.@reactive","text":"@reactive\n\nThe subscribed methods start to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc-Tuple{Any}","page":"Home","title":"Rembus.@rpc","text":"@rpc service(arg1,...)\n\nCall the remote service method and return its outcome.\n\nThe outcome may be the a return value or a RpcMethodException if the remote throws an exception.\n\nThe service method must match the signature of an exposed remote service method.\n\nComponents may subscribe to service for receiving the service request.\n\nExposer\n\nfunction mymethod(x, y)\n    return evaluate(x,y)\nend\n\n@expose mymethod\nsupervise()\n\nRPC client\n\nresponse = @rpc mymethod(x,y)\n\nSubscriber\n\nfunction service(x, y)\n    ...\nend\n\n@subscribe service\n@reactive\n\nsupervise()\n\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe","page":"Home","title":"Rembus.@subscribe","text":"@subscribe topic [mode]\n\nSetup a subscription to topic logic channel to handle messages from @publish or @rpc.\n\nmode values`:\n\nfrom_now (default): receive messages published from now.\nbefore_now: receive messages published when the component was offline.\n\nMessages starts to be delivered to topic when reactivity is enabled with @reactive macro.\n\nSubscriber\n\nfunction foo(arg1, arg2)\n    ...\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe-2","page":"Home","title":"Rembus.@subscribe","text":"@subscribe function fn(args...)\n    ...\nend [mode]\n\nSubscribe the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unexpose-Tuple{Any}","page":"Home","title":"Rembus.@unexpose","text":"@unexpose fn\n\nThe methods of fn function is no more available to rpc clients.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unreactive-Tuple{}","page":"Home","title":"Rembus.@unreactive","text":"@unreactive\n\nThe subscribed methods stop to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unsubscribe-Tuple{Any}","page":"Home","title":"Rembus.@unsubscribe","text":"@unsubscribe mytopic\n\nmytopic's methods stop to handle messages published to topic mytopic.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@wait-Tuple{}","page":"Home","title":"Rembus.@wait","text":"@wait\n\nBlock forever waiting for Ctrl-C/InterruptException or root supervisor shutdown.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
