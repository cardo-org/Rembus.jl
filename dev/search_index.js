var documenterSearchIndex = {"docs":
[{"location":"api/#Rembus-API","page":"Component API","title":"Rembus API","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"This API provides both approaches to connection handling:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"automatic reconnection in case of network failures\nexception throwing in case of network errors and reconnection explicitly managed by the application.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Rembus API functions:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"component\nconnect\nexpose\nunexpose\nrpc\nsubscribe\nunsubscribe\npublish\nreactive\nunreactive\nforever\nshared\nclose\nterminate","category":"page"},{"location":"api/#component","page":"Component API","title":"component","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Connect to the broker and return a Visor process handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"In case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = component(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The Macro-based API page documents the URL format.","category":"page"},{"location":"api/#connect","page":"Component API","title":"connect","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Connect to the broker and return a connection handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The URL string passed to connect contains the address of a broker, the transport protocol, the port and optionally a persistent unique name for the component.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The Macro-based API page documents the URL format.","category":"page"},{"location":"api/#expose","page":"Component API","title":"expose","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\nexpose(rb, myservice)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The exposed function will became available to RPC clients using the @rpc macro or the rpc function.","category":"page"},{"location":"api/#unexpose","page":"Component API","title":"unexpose","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop serving remote requests via rpc or @rpc.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"unexpose(rb, myservice)","category":"page"},{"location":"api/#rpc","page":"Component API","title":"rpc","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"response = rpc(rb, \"my_service\", Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The service name and the arguments are CBOR-encoded and transported to the remote site and the method my_service that expects a Dict as argument is called. ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The return value of my_service is transported back to the RPC client calling site and taken as the return value of rpc.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the remote method throws an Exception then the local RPC client will throw either an Exception reporting the reason of the remote error.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the exposed method expects many arguments send an array of values, where each value is an argument:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"# exposer side\nfunction my_service(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\n    return x+y+z\nend\n\n# rpc client side\nrpc(rb, \"my_service\", [1, 2, 3])","category":"page"},{"location":"api/#subscribe","page":"Component API","title":"subscribe","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Declare interest for messages published on a logical channel: the topic.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\nconnect()\n\nsubscribe(rb, mytopic)\n\nforever() # or until Ctrl-C ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"By default subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the from argument set to LastReceived():","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"connect(\"myname\")\n\nsubscribe(rb, mytopic, from=LastReceived())\n\nforever() # or until Ctrl-C","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The subscribed function will be called each time a component produce a message with the@publish macro or the publish function.","category":"page"},{"location":"api/#unsubscribe","page":"Component API","title":"unsubscribe","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop the function to receive messages produced with publish or @publish.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"unsubscribe(rb, myservice)","category":"page"},{"location":"api/#publish","page":"Component API","title":"publish","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Publish a message:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect()\n\npublish(rb, \"metric\", Dict(\"name\"=>\"trento/castello\", \"var\"=>\"T\", \"value\"=>21.0))\n\nclose(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"metric is the message topic and the Dict value is the message content.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the subscribed method expects many arguments send an array of values, where each value is an argument:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"# subscriber side\nfunction my_topic(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\nend\n\n# publisher side\npublish(rb, \"my_topic\", [1, 2, 3])","category":"page"},{"location":"api/#reactive","page":"Component API","title":"reactive","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"reactive(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The forever function starts the loop that listen for published messages and by default the reactive mode is enabled.","category":"page"},{"location":"api/#unreactive","page":"Component API","title":"unreactive","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop receiving published messages.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"unreactive(rb)","category":"page"},{"location":"api/#forever","page":"Component API","title":"forever","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Needed for components that expose and/or subscribe methods. Wait forever for rpc requests or pub/sub messages.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"By default forever enable component reactiveness, see reactive.","category":"page"},{"location":"api/#shared","page":"Component API","title":"shared","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"shared is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Using a shared state implies that an additional argument is passed to the subscribed/exposed methods.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"For convention the first argument of a method that subscribe or expose is the state object. ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The following example shows how to use a shared state:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"the struct MyState manages the state;\nthe shared method binds the state object to the component;\nthe subscribed and the exposed method must provide as first argument the state object;","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\nrb = connect(\"ingestor\")\nshared(rb, mystate)\n\n# declare interest to messages produced with\n# publish(rb, \"add_metric\", Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\nsubscribe(rb, add_metric) \n\n# implement a service that may be requested with\n# rpc(rb, \"fetch_metrics\")\nexpose(rb, fetch_metrics)\n\nforever()","category":"page"},{"location":"api/#close","page":"Component API","title":"close","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Close the network connection.   ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"close(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"NOTE: close applies to connections setup by connect api.","category":"page"},{"location":"api/#terminate","page":"Component API","title":"terminate","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Close the network connection and shutdown the supervised process associated with the component.   ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"terminate(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"NOTE: terminate applies to connections setup by component api.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"","category":"page"},{"location":"cheatsheet/#Rembus-Cheat-Sheet","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/#Startup-and-teardown","page":"Rembus Cheat Sheet","title":"Startup and teardown","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Connect to the broker with identity myname:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@component \"myname\"","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Close the connection and terminate the component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@terminate","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Loop unless Ctrl-C or shutdown():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"forever()","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: forever is required by @subscribe and @expose unless you are in the REPL.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Terminate background Rembus task and return from forever():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"shutdown()","category":"page"},{"location":"cheatsheet/#Pub/Sub:-1-publisher-and-N-subscribers","page":"Rembus Cheat Sheet","title":"Pub/Sub: 1 publisher and N subscribers","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Publish a message with topic mytopic and data payload that is the CBOR encoding of [arg1, arg2, arg3]:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@publish mytopic(arg1, arg2, arg3)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Subscribe to topic mytopic, the arguments arg1, arg2, arg3 are the CBOR decoded values of the data payload:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"# Method `mytopic` is called for each published message.\nfunction mytopic(arg1, arg2, arg3)\n    # do something\nend\n\n# Two different modes of subscription:\n@subscribe mytopic from_now # declare interest to topic mytopic handling newer messages \n@subscribe mytopic before_now # messages from the past and not received because offline\n@subscribe mytopic # default to from_now  ","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Start and stop to call subscribed methods when a published message is received:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@reactive\n@reactive_off","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Remove the topic subscription:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unsubscribe mytopic","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"By default reactive in enabled.","category":"page"},{"location":"cheatsheet/#Remote-Procedure-Call","page":"Rembus Cheat Sheet","title":"Remote Procedure Call","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Call the remote method myrpc exposed by a component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"response = @rpc myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: in case of successfull invocation the response value is the remote method return value, othervise an exception is thrown.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Expose a method implementation:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"function myrpc(arg1, arg2)\n    # evaluate body and return response ...\n    return response\nend\n\n@expose myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Stop to serve the RPC method:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unexpose myrpc","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"page"},{"location":"http_api/#HTTP-Rest-API","page":"HTTP Rest API","title":"HTTP Rest API","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus offers an HTTP REST interface for RPC requests, Pub/Sub publishing and a set of broker administration commands.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"An HTTP endpoint must be explicity activated with the http options:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"bin/caronte --http port","category":"page"},{"location":"http_api/#APIs-list","page":"HTTP Rest API","title":"APIs list","text":"","category":"section"},{"location":"http_api/#No-Auth-and-Basic-Auth-APIs","page":"HTTP Rest API","title":"No Auth and Basic Auth APIs","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET   http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/subscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/expose/{topic}/{cid}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{cid}","category":"page"},{"location":"http_api/#Basic-Auth-APIs","page":"HTTP Rest API","title":"Basic Auth APIs","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET   https://broker_host:port/admin/{command}\nPOST  https://broker_host:port/private_topic/{topic}\nPOST  https://broker_host:port/public_topic/{topic}\nPOST  https://broker_host:port/authorize/{cid}/{topic}\nPOST  https://broker_host:port/unauthorize/{cid}/{topic}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Basic-Auth is required to invoke a REST endpoint that requires client authentication:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Since Basic-Auth send the password unprotected it is strongly advised to use an encrypted https connection.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Basic-Auth POST example:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"basic_auth(str::String) = Base64.base64encode(str)\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.post(\n    \"https://127.0.0.1:9000/private_topic/my_topic\",\n    [\"Authorization\" => auth]\n)","category":"page"},{"location":"http_api/#RPC","page":"HTTP Rest API","title":"RPC","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The GET HTTP method used to make RPC requests has the following url template:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET http[s]://broker_host:port/{method_name}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"A RPC uses a GET verb because GET is used by default to request data from the server.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The return value is JSON encoded in the response body.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"For example, consider the following exposed methods by a server component:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using Rembus\n\n@expose greet(name) = \"hello $name\"\n@expose sum(x,y) = x + y","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Then the HTTP invocations by a client will be:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using HTTP\nusing JSON3\n\nsum_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/sum\", [], JSON3.write([1.0, 2.0])).body,\n    Any\n)\n\njulia_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write(\"Julia\")).body,\n    Any\n)\n\njane_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write([\"Jane\"])).body,\n    Any\n)","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The RPC GET method returns a HTTP status success 200 and the returned value in the response body if the method succeeds or a HTTP status 403 and an error description in the response body if the method fails.","category":"page"},{"location":"http_api/#Pub/Sub","page":"HTTP Rest API","title":"Pub/Sub","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The POST HTTP method used to publish a message has the following url template:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST http[s]://broker_host:port/{method_name}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The POST verb is used for Pub/Sub because by default its scope it is to send data to the server.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument, as in the case of RPC method.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The Pub/Sub POST method returns a HTTP status success 200 and an empty response body, if the method succeeds.","category":"page"},{"location":"http_api/#Subscribe-and-Expose-configuration-commands","page":"HTTP Rest API","title":"Subscribe and Expose configuration commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The REST APIS:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST  http[s]://broker_host:port/subscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/expose/{topic}/{component}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{component}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"may be used to configure in advance the \"routing\" tables of the broker, for example to to cache Pub/Sub messages for components that never connected to the broker but that in the future they will be interested to the topic messages.","category":"page"},{"location":"http_api/#Authorization-commands","page":"HTTP Rest API","title":"Authorization commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus topics come in two flawors:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"public topic accessible to all components.\nprivate topics accessible to authorized components.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The following REST commands set the privateness and authorize a component to access a private topic:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST https://broker_host:port/private_topic/{topic}\nPOST https://broker_host:port/authorize/{component}/{topic}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The HTTP header must contain a Basic-Auth property with a base64 encoded string component:password associated with a component with admin privilege.","category":"page"},{"location":"http_api/#Broker-administration-commands","page":"HTTP Rest API","title":"Broker administration commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The REST admin command set broker properties or return the broker configuration.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET https://broker_host:port/admin/{command}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The following administrations command may be invoked:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"broker_config: return the components list that expose methods and subscribe to topics.\nenable_debug: set the broker log level to DEBUG.\ndisable_debug: disable the DEBUG log level.\nload_config: reload the broker config files from disk.\nsave_config: save the broker configuration to disk.\nshutdown: shutdown the broker.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"For example the following set the broker log level to debug:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using Base64\nusing HTTP\n\nbasic_auth(str::String) = Base64.base64encode(str)\n\nadmin = \"admin\"\npassword = \"aaa\"\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.get(\n    \"http://127.0.0.1:9000/admin/enable_debug\",\n    [\"Authorization\" => auth]\n)","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"","category":"page"},{"location":"security/#Security","page":"Security","title":"Security","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"End-to-end encryption is provided by Secure Web Socket (wss) and Transport Layer Security (tls) protocols.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"Authentication and authorization are realized by using RSA keys. The component owns a secret key and the broker knows its public key.","category":"page"},{"location":"security/#End-to-end-encryption","page":"Security","title":"End-to-end encryption","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"The broker requires that in the directoy $REMBUS_KEYSTORE there are:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The server certificate rembus.crt;\nThe private key rembus.key;","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component requires a CA bundle or the CA certificate of the authority that signed the broker certificate. The environment variable HTTP_CA_BUNDLE may be used to specify the the CA file.","category":"page"},{"location":"security/#Authentication","page":"Security","title":"Authentication","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"For enabling authentication a previsous exchange of a public key or a shared secret must be performed.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the secret material is not know to the broker then the connection phase skips the authentication steps and the named component connects but without any privilege reserved to authenticated and authorized components.  ","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"For a component with name foobar that connect to the broker the authentication mechanism involves the following steps.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component sends a message declaring the name foobar;\nIf exists the file $BROKER_DB/keys/foobar then the broker replies with a random challenge;\nThe component calculates a digest, if the the $HOME/.config/rembus/keys/foobar file is a RSA private key:\nMake a SHA256 digest of a string containing the challenge plus the name foobar and signs the digest with the private key.\nOtherwise consider the file content as a shared secret and make a SHA256 digest of the string containing the challenge plus the shared secret.\nThe component send the digest to the broker;\nThe broker verifies the digest, if the the $HOME/.config/caronte/keys/foobar file is a RSA public key:\nVerify that the received digest of string containing the challenge plus the name foobar is signed by the corresponding private key;  \nOtherwise verify that the received digest equals to the digest of the string containing the\nchallenge plus the shared secret;\nReturn SUCCESS if authentication succeed, otherwise return ERROR and close the connection.","category":"page"},{"location":"security/#Authorization","page":"Security","title":"Authorization","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"By default topics are considered public, that is accessible by all components.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the topic is declared private then only authorized components may access it with the methods:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"publish\nrpc\nexpose/unexpose\nsubscribe/unsubscribe","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The topic visibility may be changed by a component with admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"rb = connect(\"superuser\")\n\n# public -> private\nprivate_topic(rb, \"my_topic\")\n\n# private -> public\npublic_topic(rb, \"my_topic\")","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"To execute such actions the admin role must be assigned to the component superuser: its name must be present in the file $HOME/.config/caronte/admins.json","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"More then one component may be assigned the admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"# admis.json\n[\"superuser\", \"foobar\"]","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"","category":"page"},{"location":"macro_api/#Macro-based-API","page":"Macro-based API","title":"Macro-based API","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The supervised API uses the metaprogramming features of Julia and provides an high level interface that make easy to integrate distributed components.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The goal of this API is to make easy developing robust and fault-tolerant distributed applications.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The following macros comprise the API and enable Julia to be supercharged with the capabilities of a middleware for RPC and Pub/Sub messaging:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component\n@expose\n@unexpose\n@rpc\n@subscribe\n@unsubscribe\n@publish\n@reactive\n@unreactive\n@forever\n@shared\n@rpc_timeout\n@terminate","category":"page"},{"location":"macro_api/#component","page":"Macro-based API","title":"component","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"A component needs to know the address of a broker, the transport protocol, the port and optionally it has to declare a persistent unique name for the component.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"These settings are defined with a URL string:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"component_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"\n\n@component component_url","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<protocol> is one of:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"ws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<host> and <port> are the hostname/ip and the port of the listening broker.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<cid> is the unique name of the component. If it is not defined create an anonymous component.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For example:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"ws://caronte.org:8000/myclient\"","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"defines the component myclient that communicates with the broker hosted on caronte.org, listening on port 8000 and accepting web socket connections.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"NOTE Rembus is \"lazy\": declaring a component does not open a connection to the broker. The connection will be opened when first needed.","category":"page"},{"location":"macro_api/#Default-component-URL-parameters","page":"Macro-based API","title":"Default component URL parameters","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The URL string may be simplified by using the enviroment variable REMBUS_BASE_URL.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Setting for example REMBUS_BASE_URL=ws://localhost:8000 the above component_url may be simplified as:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"myclient\"","category":"page"},{"location":"macro_api/#expose","page":"Macro-based API","title":"expose","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\n@expose myservice","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The exposed function will became available to RPC clients using the @rpc macro.","category":"page"},{"location":"macro_api/#unexpose","page":"Macro-based API","title":"unexpose","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop serving remote requests with @rpc requests.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unexpose myservice","category":"page"},{"location":"macro_api/#rpc","page":"Macro-based API","title":"rpc","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"response = @rpc myservice(Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The arguments of the local function call myservice is transported to the remote site and myservice method expecting a Dict as argument is executed. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The return value of myservice is transported back to the RPC client calling site and @rpc returns.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"If the remote method throws an Exception then the local RPC client throws an Exception reporting the reason of the remote error.","category":"page"},{"location":"macro_api/#subscribe","page":"Macro-based API","title":"subscribe","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Declare interest for messages published on a logical channel that usually is called topic.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\n@subscribe mytopic\n\nforever() # or until Ctrl-C ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default @subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the option before_now:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"myname\"\n\n@subscribe mytopic before_now\n\nforever() # or until Ctrl-C","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"macro_api/#unsubscribe","page":"Macro-based API","title":"unsubscribe","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop the function to receive messages produced with @publish.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unsubscribe myservice","category":"page"},{"location":"macro_api/#publish","page":"Macro-based API","title":"publish","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Publishing a message is like calling a local function named as the pub/sub topic. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@publish mytopic(1.2, 3.0)","category":"page"},{"location":"macro_api/#reactive","page":"Macro-based API","title":"reactive","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@reactive","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default a component starts with reactive mode enabled.","category":"page"},{"location":"macro_api/#unreactive","page":"Macro-based API","title":"unreactive","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop receiving published messages.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unreactive","category":"page"},{"location":"macro_api/#forever","page":"Macro-based API","title":"forever","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Needed for components that expose and/or subscribe methods. Wait forever for rpc requests or pub/sub messages.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default @forever enable component reactiveness, see @reactive.","category":"page"},{"location":"macro_api/#shared","page":"Macro-based API","title":"shared","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@shared is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Using a shared state implies that an additional argument must be passed to the methods.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For convention the first argument of a method that @subscribe or @expose is the state object. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The following example shows how to use a shared state:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"the struct MyState manages the state;\nthe @shared macro binds the state object to the component;\nthe subscribed and the exposed method must provide as first argument the state object;","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\n@component \"ingestor\"\n@shared mystate\n\n# declare interest to messages produced with\n# @publish add_metric(Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\n@subscribe add_metric \n\n# implement a service that may be requested with\n# @rpc fetch_metrics()\n@expose fetch_metrics\n\nforever()","category":"page"},{"location":"macro_api/#rpc_timeout","page":"Macro-based API","title":"rpc_timeout","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Set the maximum wait time for @rpc requests.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@rpc_timeout value_in_seconds","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default the timeout is set to 5 seconds and may be changed using REMBUS_TIMEOUT  environment variable.","category":"page"},{"location":"macro_api/#terminate","page":"Macro-based API","title":"terminate","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Close the network connection and shutdown the supervised process associated with the component.   ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@terminate","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"","category":"page"},{"location":"brokerless/#Client-Server-architecture","page":"Client-Server","title":"Client-Server architecture","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"It is possible to use Rembus protocol to setup a simple client-server architecture without a decoupling broker.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"In this scenario one component plays the role of a server that handles RPC requests and receives messages published by others components that play the role of clients.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"NOTE Without a broker a pub/sub is a one-to-one communication pattern: components publish messages that are received by the server but they are not broadcasted to anyone else.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"Below a minimal example of a component that exposes a service and accepts connections for others components and respond only to authenticated components:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"using Rembus\n\nfunction my_service(ctx, component, x, y)\n    ## authorization barrier \n    # isauthenticated(component) || error(\"unauthorized\")\n    return x+y\nend\n\nfunction start_server()\n    rb = server()\n    expose(rb, my_service)\n    forever(rb)\nend\n\nstart_server()","category":"page"},{"location":"brokerless/#Detailed-description","page":"Client-Server","title":"Detailed description","text":"","category":"section"},{"location":"brokerless/#The-Server","page":"Client-Server","title":"The Server","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The component that plays the server role is initialized as:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"rb = server()","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"expose, as usual,  make methods available to RPC clients:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"expose(rb, my_service)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The signature of my_service must have a ctx value as first argument and a component value as second argument:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"function mymethod(ctx, component, x, y)\n    return x + y\nend","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The ctx argument is a global state object that is passed to the server constructor:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"mutable struct Ctx\n    # state fields\nend\n\nctx = Ctx()\n\nrb = server(ctx)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"If a global state is not needed by default ctx is set to nothing:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"rb = server()\nexpose(rb, \"my_service\")\n\n#implies that ctx is nothing:\nfunction my_function(ctx, component, x, y)\n    @assert ctx === nothing\nend","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The component object if useful for:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"serving only authenticated components;\nstoring component session state into session(component) dictionary;","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"forever is the final step: the server starts and waits for connection requests from clients:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"Rembus.forever(rb)","category":"page"},{"location":"brokerless/#The-Client","page":"Client-Server","title":"The Client","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"On the calling side the rpc method has to be invoked with two arguments:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"@rpc my_service(x,y)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"","category":"page"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/#Broker-environment-variables","page":"Configuration","title":"Broker environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The broker setup is affected by the following environment variables.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_DIR $HOME/.config/rembus data root directory\nBROKER_WS_PORT 8000 default port for serving WebSocket protocol\nREMBUS_DEBUG  \"1\": enable debug traces\nREMBUS_KEYSTORE $REMBUS_ROOT_DIR/keystore Directory of broker/server certificate rembus.crt and broker/server secret key rembus.key","category":"page"},{"location":"configuration/#Component-environment-variables","page":"Configuration","title":"Component environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A Rembus component is affected by the following environment variables.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_DIR $HOME/.config/rembus data root directory\nREMBUS_BASE_URL ws://localhost:8000 Default base url when defining component with  a simple string instead of a complete url. @component \"myclient\" is equivalent to @component \"ws://localhost:8000/myclient\"\nREMBUS_DEBUG  \"1\": enable debug traces\nREMBUS_TIMEOUT 5 Maximum number of seconds waiting for rpc responses\nHTTP_CA_BUNDLE $REMBUS_ROOT_DIR/ca/rembus-ca.crt CA certificate","category":"page"},{"location":"configuration/#Broker-configuration-files","page":"Configuration","title":"Broker configuration files","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The broker name determines the directory where the data files are stored.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example, to set the name of the broker with the companion broker script use the optional name argument:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"broker --name my_broker","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"In the following it is assumed the default caronte name for the broker: in this case the directory $REMBUS_DIR/caronte contains the broker settings and secret materials.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cd ~/.config/rembus/caronte\n> tree .\n\n.\n admins.json\n keys\n  bar.rsa.pem\n  foo.ecdsa.pem\n exposers.json\n tenants.json\n component_owner.json\n topic_auth.json\n twins.json\n messages\n   1345\n   345456\n   867687\n","category":"page"},{"location":"configuration/#Secret-material-for-authenticated-components","page":"Configuration","title":"Secret material for authenticated components","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A file in the keys directory contains the secret material used to authenticate the component.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"This file may contain:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"a RSA public key;\nan ECDSA public key;\na plaintext shared password string;","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"To create the RSA or ECDSA  key pairs and send the public key to the broker the Rembus.register method may be employed.","category":"page"},{"location":"configuration/#Components-with-admin-privilege","page":"Configuration","title":"Components with admin privilege","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"admins.json contains the list of components that have the admin role. The element of this list are component names.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat admins.json\n[\"foo\", \"bar\"]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A component with admin privilege may change the privateness level of topics and authorize other components to bind to private topics.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"See private_topic, public_topic, authorize, unauthorize for details.","category":"page"},{"location":"configuration/#RPC-exposers","page":"Configuration","title":"RPC exposers","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"exposers.json is a map with topic as keyword and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The topic keyword is the name of an RPC method exposed by all components present in the value array.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat exposers.json\n{\n    \"topic_1\":[\"foo\"],\n    \"topic_2\":[\"foo\", \"bar\"]\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"foo component exposes topic_1 and topic_2 rpc methods.\nbar component exposes topic_2 rpc method.","category":"page"},{"location":"configuration/#Pub/Sub-subscribers","page":"Configuration","title":"Pub/Sub subscribers","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The topics subscribers are persisted in the file subscribers.json. Only named component are persisted.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"subscribers.json contains a map: keywords are component names and values are maps. The keys of the map are subscribed topics and values are floats that define time periods in microseconds. A message received before the node subscription time but included in the time period will be delivered to the node.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example, in the following setting mytopic1 does not get messages received before the subscription because the time period is zero, while messages more recent than one hour are delivered to topic2:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If the time period is Inf then all messages received before the time of subscription and not delivered because the node was offline are sent to it.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat subscribers.json\n{\n    \"mycomponent\":{\"mytopic1\": 0.0, \"mytopic2\": 3.6e9}\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For declaring interest for all messaged delivered wheh the node was offline with Macro-based API use from=LastReceived() expression:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"@subscribe mytopic1 from=LastReceived()","category":"page"},{"location":"configuration/#Private-topics","page":"Configuration","title":"Private topics","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"topic_auth.json is a map with topic as keywords and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat topic_auth.json\n{\n    \"foo\":[\"myconsumer\",\"myproducer\"]\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"asserts then only components myconsumer and myproducer are allowed to bind to the topic foo.","category":"page"},{"location":"configuration/#Users-allowed-to-register-components","page":"Configuration","title":"Users allowed to register components","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Authenticated components may be provisioned with the Rembus.register method.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"register(component_name, uid, pin, key_type=SIG_RSA)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"key_type may be equal to SIG_RSA for RSA Encryption and equal to SIG_ECDSA for Elliptic Curve Digital Signature Algorithm.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"register requires a tenant and a pin that must match with one of the users defined in tenants.json file. ","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenants.json file example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[\n    {\n        \"tenant\": \"A\",\n        \"pin\": \"482dc7eb\",\n        \"enabled\": true\n    },\n    {\n        \"tenant\": \"B\",\n        \"pin\": \"58e26283\",\n    },\n\n]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant is the tenant identifier.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"pin is a secret token used for authentication. The pin column is a 8 digits string  composed of numbers and the characters [a-f]. ","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"enabled consent to disable the tenant and this does not allow to register new components.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"enabled is optional and if not present it defaults to true.","category":"page"},{"location":"configuration/#Components-ownership","page":"Configuration","title":"Components ownership","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant_component.json contains the mapping between the registered component and the tenant to which it belong.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant is the tenant identifier and component is the component identifier.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example if the tenant A registered the component foo then tenant_component.json  will be:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[\n    {\"tenant\": \"A\",\"component\": \"foo\"}    \n]","category":"page"},{"location":"configuration/#Files-reserved-to-the-broker","page":"Configuration","title":"Files reserved to the broker","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"twins.json get saved at broker shutdown and contains, for each component, the reference for the last message delivered to the component. It is a file managed by the broker, do no edit this file.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"the files in messages directory are parquet files that get saved periodically and at broker shutdown and contain all the published messages.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"fault_tolerance/#Fault-tolerance-features","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"section"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Beside struggling to provide a simple and lean API one of the main points of Rembus is its ability to be fault-tolerant respect to networks and application failures.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"The Macro-based API and the component method provide an automatic reconnection policy in case of network faults and try at the best to guarantee message delivery when faults happen.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"This mean that the following RPC service will run forever and it will reconnect automatically in case of network failures or broker unavailability.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"mycomponent\"\n\nfunction myservice(input::DataFrame)\n    # run your super-cool logic and get back the result\n    output_df = my_logic(input)\n    return output_df\nend\n\n@expose myservice\n\n@forever","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Fault-tolerance holds equally for publish/subscribe setups: in case of connection lost the subscriber retries to reconnect to the broker until the connection will be up again.   ","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"If the subscription use the before_now option then messages published whereas the component was offline are delivered ordered by time of publishing when the component get online again.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"consumer\"\n\nfunction mytopic(input::DataFrame)\n    # consume the dataframe posted to mytopic topic\nend\n\n@subscribe mytopic before_now\n\n@forever","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"page"},{"location":"#Rembus","page":"Home","title":"Rembus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Rembus","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rembus is a middleware for Pub/Sub and RPC communication styles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two types of processes: Components and Brokers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Component connect to a Broker;\nA Broker dispatch messages between Components;\nA Component expose RPC services and/or subscribe to Pub/Sub topics;\nA Component make RPC requests and/or publish messages to Pub/Sub topics;","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Rembus\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rembus installs and compiles in a minute or two.","category":"page"},{"location":"#Broker","page":"Home","title":"Broker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Broker is a process that routes messages between components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Broker is capable of making components that use different transport protocols talk to each other. For example a component that uses a ZeroMQ socket may talk to a component that uses the WebSocket protocol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting a Broker is simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Rembus\n\ncaronte()","category":"page"},{"location":"","page":"Home","title":"Home","text":"A startup script could be useful and the following caronte script will do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"##!/bin/bash\n#=\nBINDIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\nexec julia --threads auto --color=no -e\"include(popfirst!(ARGS))\" \\\n --project=$BINDIR/.. --startup-file=no \"${BASH_SOURCE[0]}\" \"$@\"\n=#\nusing Rembus\n\ncaronte()","category":"page"},{"location":"","page":"Home","title":"Home","text":"caronte starts by default a WebSocket server listening on port 8000, for enabling tcp and/or zmq transports use the appropriate arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"shell> ./caronte\nusage: caronte [-r] [-s] [-p HTTP] [-w WS] [-t TCP] [-z ZMQ] [-d] [-h]\n\noptional arguments:\n  -r, --reset      factory reset, clean up broker configuration\n  -s, --secure     accept wss and tls connections\n  -p, --http HTTP  accept HTTP clients on port HTTP (type: UInt16)\n  -w, --ws WS      accept WebSocket clients on port WS (type: UInt16)\n  -t, --tcp TCP    accept tcp clients on port TCP (type: UInt16)\n  -z, --zmq ZMQ    accept zmq clients on port ZMQ (type: UInt16)\n  -d, --debug      enable debug logs\n  -h, --help       show this help message and exit","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Broker environment variables for customizing the runtime setting.  ","category":"page"},{"location":"#Component","page":"Home","title":"Component","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Component is a process that plays one or more of the following roles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Publisher (Pub/Sub) : produce messages;\nSubscriber (Pub/Sub): consume published messages;\nRequestor (RPC): request a service;\nExposer (RPC): execute a service request and give back a response;","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are three type of components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Anonymous\nNamed\nAuthenticated","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Anonymous component assume a random and ephemeral identity each time it connects to the broker. Example usage for anonymous components may be:","category":"page"},{"location":"","page":"Home","title":"Home","text":"when it is not required to trace the originating source of messages;\nfor a Subscriber not interested to receive messages published when it was offline;\nfor preliminary prototyping;","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Named component has a unique and persistent name that make possible to receive messages published when the component was offline.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Authenticated component is a named component that own a private key or a shared secret which can prove its identity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Only authenticated components may use Pub/Sub private topics and private RPC methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An URL string defines the identity and the connection parameters of a component. The Macro-based API page documents the URL format.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Rembus]","category":"page"},{"location":"#Rembus.RembusTimeout","page":"Home","title":"Rembus.RembusTimeout","text":"RembusTimeout\n\nThrown when a response it is not received.\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodException","page":"Home","title":"Rembus.RpcMethodException","text":"RpcMethodException\n\nThrown when a RPC method throws an exception.\n\nFields\n\ncid: component name\ntopic: service name\nreason: remote exception description\n\nExposer\n\n@expose foo(name::AbstractString) = \"hello \" * name\n\nRPC client\n\ntry\n    @rpc foo(1)\ncatch e\n    @error e.reason\nend\n\nOutput:\n\n Error: MethodError: no method matching foo(::UInt64)\n\n Closest candidates are:\n   foo(!Matched::AbstractString)\n    @ Main REPL[2]:1\n @ Main REPL\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodLoopback","page":"Home","title":"Rembus.RpcMethodLoopback","text":"RpcMethodLoopback\n\nThrown when a RPC request would invoke a locally exposed method.\n\nFields\n\ncid: component name\ntopic: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodNotFound","page":"Home","title":"Rembus.RpcMethodNotFound","text":"RpcMethodNotFound is thrown from a rpc request when the called method is unknown.\n\nfields:\n\ncid: component name\ntopic: service name\n\nRPC Client\n\n@rpc coolservice()\n\nOutput:\n\nERROR: Rembus.RpcMethodNotFound(\"rembus\", \"coolservice\")\nStacktrace:\n...\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodUnavailable","page":"Home","title":"Rembus.RpcMethodUnavailable","text":"RpcMethodUnavailable\n\nThrown when a RPC method is unavailable.\n\nA method is considered unavailable when some component that exposed the method is currently disconnected from the broker.\n\nFields\n\ncid: component name\ntopic: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.authorize-Tuple{Rembus.RBHandle, AbstractString, AbstractString}","page":"Home","title":"Rembus.authorize","text":"function authorize(\n    rb::RBHandle, client::AbstractString, topic::AbstractString;\n    exceptionerror=true\n)\n\nAuthorize the client component to use the private topic.\n\nThe component must have the admin role for granting topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.caronte-Tuple{}","page":"Home","title":"Rembus.caronte","text":"caronte(;\n    wait=true,\n    mode=nothing,\n    log=\"info\",\n    plugin=nothing,\n    context=nothing,\n    args=Dict()\n)\n\nStart the broker.\n\nReturn immediately when wait is false, otherwise blocks until shutdown is requested.\n\nOverwrite command line arguments if args is not empty.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.component","page":"Home","title":"Rembus.component","text":"component(url)\n\nConnect rembus component defined by url.\n\nThe connection is supervised and network faults starts connection retries attempts until successful outcome.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.component-Tuple{Vector}","page":"Home","title":"Rembus.component","text":"component(urls::Vector)\n\nConnect component to remotes defined be urls array.\n\nThe connection pool is supervised.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.connect-Tuple{AbstractString}","page":"Home","title":"Rembus.connect","text":"connect(url::AbstractString)::RBHandle\n\nConnect to the broker.\n\nThe returned rembus handler do not auto-reconnect in case of a fault condition.\n\nThe returned RBHandle handle represents a connected component used for the Rembus APIs. For example:\n\nusing Rembus\nrb = connect(\"mycomponent\")\npublish(rb, \"temperature\", [\"room_1\", 21.5])\n\nThe url argument string is formatted as:\n\nurl = [<protocol>://][<host>][:<port>/]<cid>\n\n<protocol> is one of:\n\nws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket\n\n<host> and <port> are the hostname/ip and the port of the listening broker.\n\n<cid> is the unique name of the component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.connect-Tuple{}","page":"Home","title":"Rembus.connect","text":"connect()\n\nConnect anonymously to the endpoint declared with REMBUS_BASE_URL env variable.\n\nREMBUS_BASE_URL default to ws://127.0.0.1:8000\n\nA component is considered anonymous when a different and random UUID is used as component identifier each time the application connect to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.expose-Tuple{Rembus.RBHandle, AbstractString, Function}","page":"Home","title":"Rembus.expose","text":"expose(rb::RBHandle, fn::Function; exceptionerror=true)\nexpose(rb::RBHandle, topic::AbstractString, fn::Function; exceptionerror=true)\n\nExpose the methods of function fn to be executed by rpc clients using topic as RPC method name.\n\nIf the topic argument is omitted the function name equals to the RPC method name.\n\nfn returns the RPC response.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.forever-Tuple{Rembus.RBHandle}","page":"Home","title":"Rembus.forever","text":"forever(rb::RBHandle)\n\nStart the event loop awaiting to execute exposed and subscribed methods.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.forever-Tuple{Rembus.Server}","page":"Home","title":"Rembus.forever","text":"forever(server::Server; wait=true, secure=false)\n\nStart an embedded server and accept connections.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.forever-Tuple{Visor.Process}","page":"Home","title":"Rembus.forever","text":"forever(rb::Visor.Process)\n\nStart the event loop awaiting to execute exposed and subscribed methods.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.isauthenticated-Tuple{Any}","page":"Home","title":"Rembus.isauthenticated","text":"isauthenticated(session)\n\nReturn true if the connected component is authenticated.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.private_topic-Tuple{Rembus.RBHandle, AbstractString}","page":"Home","title":"Rembus.private_topic","text":"private_topic(rb::RBHandle, topic::AbstractString; exceptionerror=true)\n\nSet the topic to private.\n\nThe component must have the admin role for changing the privateness level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.public_topic-Tuple{Rembus.RBHandle, AbstractString}","page":"Home","title":"Rembus.public_topic","text":"public_topic(rb::RBHandle, topic::AbstractString; exceptionerror=true)\n\nSet the topic to public.\n\nThe component must have the admin role for changing the privateness level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.publish","page":"Home","title":"Rembus.publish","text":"publish(rb::RBHandle, topic::AbstractString, data=[]; qos=QOS0)\n\nPublish data values on topic.\n\ndata may be a value or a vector of values. Each value map to the arguments of the subscribed method.\n\nFor example if the subscriber is a method that expects two arguments:\n\nmytopic(x,y) = @info \"x=$x, y=$y\"\n\nThe published message needs an array of two elements:\n\npublish(rb, \"mytopic\", [1, 2])\n\nWhen a subscribed method expect one argument instead of passing an array of one element it may be better to pass the value:\n\nmytopic(x) = @info \"x=$x\"\n\npublish(rb, \"mytopic\", 1)\n\nIf the subscribed method has no arguments invoke publish as:\n\nmytopic() = @info \"mytopic invoked\"\n\npublish(rb, \"mytopic\")\n\ndata array may contains any type, but if the components are implemented in different languages then data has to be a DataFrame or a primitive type that is CBOR encodable.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.reactive-Tuple{Rembus.RBHandle}","page":"Home","title":"Rembus.reactive","text":"reactive(\n    rb::RBHandle;\n    from::Union{Real,Period,Dates.CompoundPeriod}=Day(1),\n    exceptionerror=true\n)\n\nStart the delivery of published messages for which there was declared an interest with subscribe.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.register-Tuple{AbstractString, AbstractString}","page":"Home","title":"Rembus.register","text":"register(\n    cid::AbstractString,\n    pin::AbstractString;\n    tenant=Union{Nothing, AbstractString} = nothing,\n    scheme::UInt8\n)\n\nRegister the component with name cid.\n\nTo register a component a single pin or a set of tenants must be configured in the tenants.json file.\n\nThe pin shared secret is a 8 hex digits string (for example \"deedbeef\").\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rpc","page":"Home","title":"Rembus.rpc","text":"rpc(rb::RBHandle,\n    topic::AbstractString,\n    data=nothing;\n    exceptionerror=true,\n    timeout=request_timeout())\n\nCall the remote topic method with arguments extracted from data.\n\nExposer\n\nusing Rembus\nusing Statistics\n\n@expose service_noargs() = \"success\"\n\n@expose service_name(name) = \"hello \" * name\n\n@expose service_dictionary(d) = mean(values(d))\n\n@expose function service_multiple_args(name, score, flags)\n    isa(name, String) && isa(score, Float64) && isa(flags, Vector)\nend\n\nRPC client\n\nusing Rembus\n\nrb = connect()\n\nrcp(rb, \"service_noargs\")\n\nrpc(rb, \"service_name\", \"hello world\")\n\nrpc(rb, \"service_dictionary\", Dict(\"r1\"=>13.3, \"r2\"=>3.0))\n\nrpc(rb, \"service_multiple_args\", [\"name\", 1.0, [\"red\"=>1,\"blue\"=>2,\"yellow\"=>3]])\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.server","page":"Home","title":"Rembus.server","text":"server(\n    ctx=nothing;\n    secure=false,\n    ws=nothing,\n    tcp=nothing,\n    name=\"server\",\n    mode=nothing,\n    log=TRACE_INFO\n)\n\nInitialize a server node.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.shared-Tuple{Rembus.RBHandle, Any}","page":"Home","title":"Rembus.shared","text":"shared(rb::RBHandle, ctx)\n\nBind a ctx context object to the rb component.\n\nWhen a ctx context object is bound then it will be the first argument of subscribed and exposed methods.\n\nSee @shared for more details.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.subscribe-Tuple{Rembus.RBConnection, AbstractString, Function}","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb::RBHandle, fn::Function; from=Now(), exceptionerror=true)\nsubscribe(\n    rb::RBHandle, topic::AbstractString, fn::Function; from=Now(),\n    exceptionerror=true\n)\n\nDeclare interest for messages published on topic logical channel.\n\nThe function fn is called when a message is received on topic and reactive put the rb component in reactive mode.\n\nIf the topic argument is omitted the function name must be equal to the topic name.\n\nIf from is LastReceived() then rb component will receive messages published when it was offline.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unauthorize-Tuple{Rembus.RBHandle, AbstractString, AbstractString}","page":"Home","title":"Rembus.unauthorize","text":"function unauthorize(\n    rb::RBHandle, client::AbstractString, topic::AbstractString;\n    exceptionerror=true\n)\n\nRevoke authorization to the client component for use of the private topic.\n\nThe component must have the admin role for revoking topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.RBHandle, AbstractString}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb::RBHandle, fn::Function; exceptionerror=true)\nunexpose(rb::RBHandle, topic::AbstractString; exceptionerror=true)\n\nStop servicing RPC requests targeting topic or fn methods.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unreactive-Tuple{Rembus.RBHandle}","page":"Home","title":"Rembus.unreactive","text":"unreactive(rb::RBHandle, timeout=5; exceptionerror=true)\n\nStop the delivery of published message.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unregister-Tuple{Rembus.RBConnection}","page":"Home","title":"Rembus.unregister","text":"unregister(rb)\n\nUnregister the connected component.\n\nOnly a connected and authenticated component may execute the unregister command.\n\nusing Rembus\n\nrb = connect(\"authenticated_component\")\nRembus.unregister(rb)\nclose(rb)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.RBHandle, AbstractString}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb::RBHandle, topic::AbstractString; exceptionerror=true)\nunsubscribe(rb::RBHandle, fn::Function; exceptionerror=true)\n\nNo more messages published on a topic logical channel or a topic name equals to the name of the subscribed function will be delivered to rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.@component-Tuple{Any}","page":"Home","title":"Rembus.@component","text":"@component \"url\"\n\nSet the name of the component and the protocol for connecting to the broker.\n\nurl may be:\n\n\"myname\": use $REMBUS_BASE_URL for connection parameters\n\"tcp://host:port/myname\": tcp connection\n\"ws://host:port/myname\": web socket connection\n\"zmq://host:port/myname\": ZeroMQ connection\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Expr}","page":"Home","title":"Rembus.@expose","text":"@expose function fn(arg1,...)\n    ...\nend\n\nExpose the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Symbol}","page":"Home","title":"Rembus.@expose","text":"@expose fn\n\nExpose all the methods of the function fn.\n\nExample\n\nExpose the function mycalc that implements a service that may accept two numbers or a string and number:\n\nmycalc(x::Number, y::Number) = x+y\nmycalc(x::String, y::Number) = length(x)*y\n\n@expose mycalc\n\nCall mycal service using the correct types of arguments:\n\n# ok\njulia> response = @rpc mycalc(1,2)\n0x0000000000000003\n\n# ok\njulia> response = @rpc mycalc(\"hello\",2.0)\n10.0\n\nIf the RPC client call mycalc with the argument's type that do not respect the signatures of the exposed service then it throws RpcMethodException\n\njulia> response = @rpc mycalc(\"hello\",\"world\")\nERROR: RpcMethodException(\"rembus\", \"mycalc\", \"MethodError: no method matching mycalc(::String, ::String) ...\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@forever-Tuple{}","page":"Home","title":"Rembus.@forever","text":"@forever\n\nStart the event loop awaiting to execute exposed and subscribed methods.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@publish","page":"Home","title":"Rembus.@publish","text":"@publish topic(arg1,arg2,...)\n\nPublish a message to topic logic channel.\n\nThe function topic(arg1,arg2,...) will be called on each connected component subscribed to topic.\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\nSubscriber\n\nfunction foo(name, value)\n    println(\"do something with $name=$value\")\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@reactive","page":"Home","title":"Rembus.@reactive","text":"@reactive\n\nThe subscribed methods start to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@reactive-2","page":"Home","title":"Rembus.@reactive","text":"@reactive\n\nThe subscribed methods start to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc-Tuple{Any}","page":"Home","title":"Rembus.@rpc","text":"@rpc service(arg1,...)\n\nCall the remote service method and return its outcome.\n\nThe outcome may be the a return value or a RpcMethodException if the remote throws an exception.\n\nThe service method must match the signature of an exposed remote service method.\n\nComponents may subscribe to service for receiving the service request.\n\nExposer\n\nfunction mymethod(x, y)\n    return evaluate(x,y)\nend\n\n@expose mymethod\nsupervise()\n\nRPC client\n\nresponse = @rpc mymethod(x,y)\n\nSubscriber\n\nfunction service(x, y)\n    ...\nend\n\n@subscribe service\n@reactive\n\nsupervise()\n\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc_timeout-Tuple{Any}","page":"Home","title":"Rembus.@rpc_timeout","text":"@rpc_timeout value\n\nSet the rpc request timeout in seconds.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@shared-Tuple{Any}","page":"Home","title":"Rembus.@shared","text":" @shared container\n\nBind a container object that is passed as the first argument of the subscribed component functions.\n\nThe container is useful for mantaining a state.\n\nusing Rembus\n\n# keep the number of processed messages\nmutable struct Context\n    msgcount::UInt\nend\n\nfunction topic(context::Context, arg1, arg2)\n    context.msgcount += 1\n    some_logic(arg1, arg2)\nend\n\nctx = Context(0)\n@subscribe topic\n@shared ctx\n\nUsing @shared to set a container object means that if some component publish topic(arg1,arg2) then the method foo(container,arg2,arg2) will be called.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe","page":"Home","title":"Rembus.@subscribe","text":"@subscribe topic [mode]\n\nSetup a subscription to topic logic channel to handle messages from @publish or @rpc.\n\nmode values`:\n\nfrom_now (default): receive messages published from now.\nbefore_now: receive messages published when the component was offline.\n\nMessages starts to be delivered to topic when reactivity is enabled with @reactive macro.\n\nSubscriber\n\nfunction foo(arg1, arg2)\n    ...\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe-2","page":"Home","title":"Rembus.@subscribe","text":"@subscribe function fn(args...)\n    ...\nend [mode]\n\nSubscribe the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@terminate","page":"Home","title":"Rembus.@terminate","text":"@terminate\n\nClose the connection and terminate the component.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unexpose-Tuple{Symbol}","page":"Home","title":"Rembus.@unexpose","text":"@unexpose fn\n\nThe methods of fn function is no more available to rpc clients.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unreactive","page":"Home","title":"Rembus.@unreactive","text":"@unreactive\n\nThe subscribed methods stop to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unsubscribe-Tuple{Symbol}","page":"Home","title":"Rembus.@unsubscribe","text":"@unsubscribe mytopic\n\nThe methods of mytopic function stop to handle messages published to topic mytopic.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
