var documenterSearchIndex = {"docs":
[{"location":"unsupervised_api/#Unsupervised-API","page":"Unsupervised API","title":"Unsupervised API","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"This API does not provide automatic reconnection in case of network failures, if this happen the exception must be handled explicitly by the application.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The unsupervised API functions:","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"connect\nexpose\nunexpose\nrpc\nsubscribe\nunsubscribe\npublish\nreactive\nunreactive\nshared\nclose","category":"page"},{"location":"unsupervised_api/#connect","page":"Unsupervised API","title":"connect","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Connect to the broker and return a connection handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The URL string passed to connect contains the address of a broker, the transport protocol, the port and optionally a persistent unique name for the component.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"rb = connect(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The Supervised API page documents the URL format.","category":"page"},{"location":"unsupervised_api/#expose","page":"Unsupervised API","title":"expose","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\nexpose(rb, myservice)","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The exposed function will became available to RPC clients using the @rpc macro.","category":"page"},{"location":"unsupervised_api/#unexpose","page":"Unsupervised API","title":"unexpose","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Stop serving remote requests with @rpc requests.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"unexpose(rb, myservice)","category":"page"},{"location":"unsupervised_api/#rpc","page":"Unsupervised API","title":"rpc","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"response = rpc(rb, \"myservice\", Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The service name and the arguments are transported to the remote site and myservice method expecting a Dict as argument is executed. ","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The return value of myservice is transported back to the RPC client calling site and rpc returns.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"If the remote method throws an Exception then the local RPC client will throw either an Exception reporting the reason of the remote error.","category":"page"},{"location":"unsupervised_api/#subscribe","page":"Unsupervised API","title":"subscribe","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Declare interest for messages published on a logical channel: the topic.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\nconnect()\n\nsubscribe(rb, mytopic)\n\nforever() # or until Ctrl-C ","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"By default subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the retroactive argument set to true:","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"connect(\"myname\")\n\nsubscribe(rb, mytopic, true)\n\nforever() # or until Ctrl-C","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"unsupervised_api/#unsubscribe","page":"Unsupervised API","title":"unsubscribe","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Stop the function to receive messages produced with publish.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"unsubscribe(rb, myservice)","category":"page"},{"location":"unsupervised_api/#publish","page":"Unsupervised API","title":"publish","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Publish a message:","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"rb = connect()\n\npublish(rb, \"metric\", Dict(\"name\"=>\"trento/castello\", \"var\"=>\"T\", \"value\"=>21.0))\n\nclose(rb)","category":"page"},{"location":"unsupervised_api/#reactive","page":"Unsupervised API","title":"reactive","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"reactive(rb)","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"By default a component starts with reactive mode enabled.","category":"page"},{"location":"unsupervised_api/#unreactive","page":"Unsupervised API","title":"unreactive","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Stop receiving published messages.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"unreactive(rb)","category":"page"},{"location":"unsupervised_api/#shared","page":"Unsupervised API","title":"shared","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"shared is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Using a shared state implies that an additional argument must be passed to the methods.","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"For convention the first argument of a method that subscribe or expose is the state object. ","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"The following example shows how to use a shared state:","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"the struct MyState manages the state;\nthe shared method binds the state object to the component;\nthe subscribed and the exposed method must provide as first argument the state object;","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\nrb = connect(\"ingestor\")\nshared(rb, mystate)\n\n# declare interest to messages produced with\n# publish(rb, \"add_metric\", Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\nsubscribe(rb, add_metric) \n\n# implement a service that may be requested with\n# rpc(rb, \"fetch_metrics\")\nexpose(rb, fetch_metrics)\n\nforever()","category":"page"},{"location":"unsupervised_api/#close","page":"Unsupervised API","title":"close","text":"","category":"section"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"Close the network connection.   ","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"close(rb)","category":"page"},{"location":"unsupervised_api/","page":"Unsupervised API","title":"Unsupervised API","text":"","category":"page"},{"location":"cheatsheet/#Rembus-Cheat-Sheet","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/#Startup-and-teardown","page":"Rembus Cheat Sheet","title":"Startup and teardown","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Connect to the broker with identity myname:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@component \"myname\"","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Close the connection and terminate the component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@terminate","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Loop unless Ctrl-C or shutdown():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"forever()","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: forever is required by @subscribe and @expose unless you are in the REPL.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Terminate background Rembus task and return from forever():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"shutdown()","category":"page"},{"location":"cheatsheet/#Pub/Sub:-1-publisher-and-N-subscribers","page":"Rembus Cheat Sheet","title":"Pub/Sub: 1 publisher and N subscribers","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Publish a message with topic mytopic and data payload that is the CBOR encoding of [arg1, arg2, arg3]:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@publish mytopic(arg1, arg2, arg3)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Subscribe to topic mytopic, the arguments arg1, arg2, arg3 are the CBOR decoded values of the data payload:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"# Method `mytopic` is called for each published message.\nfunction mytopic(arg1, arg2, arg3)\n    # do something\nend\n\n# Two different modes of subscription:\n@subscribe mytopic from_now # declare interest to topic mytopic handling newer messages \n@subscribe mytopic before_now # messages from the past and not received because offline\n@subscribe mytopic # default to from_now  ","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Start and stop to call subscribed methods when a published message is received:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@reactive\n@reactive_off","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Remove the topic subscription:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unsubscribe mytopic","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"By default reactive in enabled.","category":"page"},{"location":"cheatsheet/#Remote-Procedure-Call","page":"Rembus Cheat Sheet","title":"Remote Procedure Call","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Call the remote method myrpc exposed by a component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"response = @rpc myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: in case of successfull invocation the response value is the remote method return value, othervise an exception is thrown.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Expose a method implementation:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"function myrpc(arg1, arg2)\n    # evaluate body and return response ...\n    return response\nend\n\n@expose myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Stop to serve the RPC method:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unexpose myrpc","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"page"},{"location":"supervised_api/#Supervised-API","page":"Supervised API","title":"Supervised API","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The supervised API uses the metaprogramming features of Julia and provides something similar to a simple language extension.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The goal of this API is to make easy developing robust and fault-tolerant distributed applications.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The following macros comprise the API and enable Julia to be supercharged with the capabilities of a middleware for RPC and Pub/Sub messaging:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@component\n@expose\n@unexpose\n@rpc\n@subscribe\n@unsubscribe\n@publish\n@reactive\n@unreactive\n@shared\n@rpc_timeout\n@terminate","category":"page"},{"location":"supervised_api/#component","page":"Supervised API","title":"component","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"A component needs to know the address of a broker, the transport protocol, the port and optionally it has to declare a persistent unique name for the component.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"These settings are defined with a URL string:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"component_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"\n\n@component component_url","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"<protocol> is one of:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"ws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"<host> and <port> are the hostname/ip and the port of the listening broker.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"<cid> is the unique name of the component. If it is not defined create an anonymous component.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"For example:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@component \"ws://caronte.org:8000/myclient\"","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"defines the component myclient that communicates with the broker hosted on caronte.org, listening on port 8000 and accepting web socket connections.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"NOTE Rembus is \"lazy\": declaring a component does not open a connection to the broker. The connection will be opened when first needed.","category":"page"},{"location":"supervised_api/#Default-component-URL-parameters","page":"Supervised API","title":"Default component URL parameters","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The URL string may be simplified by using the enviroment variable REMBUS_BASE_URL.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Setting for example REMBUS_BASE_URL=ws://localhost:8000 the above component_url may be simplified as:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@component \"myclient\"","category":"page"},{"location":"supervised_api/#expose","page":"Supervised API","title":"expose","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\n@expose myservice","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The exposed function will became available to RPC clients using the @rpc macro.","category":"page"},{"location":"supervised_api/#unexpose","page":"Supervised API","title":"unexpose","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Stop serving remote requests with @rpc requests.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@unexpose myservice","category":"page"},{"location":"supervised_api/#rpc","page":"Supervised API","title":"rpc","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"response = @rpc myservice(Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The arguments of the local function call myservice is transported to the remote site and myservice method expecting a Dict as argument is executed. ","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The return value of myservice is transported back to the RPC client calling site and @rpc returns.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"If the remote method throws an Exception then the local RPC client throws an Exception reporting the reason of the remote error.","category":"page"},{"location":"supervised_api/#subscribe","page":"Supervised API","title":"subscribe","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Declare interest for messages published on a logical channel that usually is called topic.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\n@subscribe mytopic\n\nforever() # or until Ctrl-C ","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"By default @subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the option before_now:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@component \"myname\"\n\n@subscribe mytopic before_now\n\nforever() # or until Ctrl-C","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"supervised_api/#unsubscribe","page":"Supervised API","title":"unsubscribe","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Stop the function to receive messages produced with @publish.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@unsubscribe myservice","category":"page"},{"location":"supervised_api/#publish","page":"Supervised API","title":"publish","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Publishing a message is like calling a local function named as the pub/sub topic. ","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@publish mytopic(1.2, 3.0)","category":"page"},{"location":"supervised_api/#reactive","page":"Supervised API","title":"reactive","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@reactive","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"By default a component starts with reactive mode enabled.","category":"page"},{"location":"supervised_api/#unreactive","page":"Supervised API","title":"unreactive","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Stop receiving published messages.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@unreactive","category":"page"},{"location":"supervised_api/#shared","page":"Supervised API","title":"shared","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@shared is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Using a shared state implies that an additional argument must be passed to the methods.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"For convention the first argument of a method that @subscribe or @expose is the state object. ","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"The following example shows how to use a shared state:","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"the struct MyState manages the state;\nthe @shared macro binds the state object to the component;\nthe subscribed and the exposed method must provide as first argument the state object;","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\n@component \"ingestor\"\n@shared mystate\n\n# declare interest to messages produced with\n# @publish add_metric(Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\n@subscribe add_metric \n\n# implement a service that may be requested with\n# @rpc fetch_metrics()\n@expose fetch_metrics\n\nforever()","category":"page"},{"location":"supervised_api/#rpc_timeout","page":"Supervised API","title":"rpc_timeout","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Set the maximum wait time for @rpc requests.","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@rpc_timeout value_in_seconds","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"By default the timeout is set to 5 seconds and may be changed using REMBUS_TIMEOUT  environment variable.","category":"page"},{"location":"supervised_api/#terminate","page":"Supervised API","title":"terminate","text":"","category":"section"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"Close the network connection and shutdown the supervised process associated with the component.   ","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"@terminate","category":"page"},{"location":"supervised_api/","page":"Supervised API","title":"Supervised API","text":"","category":"page"},{"location":"security/#Security","page":"Security","title":"Security","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"End-to-end encryption is provided by Secure Web Socket (wss) and Transport Layer Security (tls) protocols.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"Authentication and authorization are realized by using RSA keys. The component owns a secret key and the broker knows its public key.","category":"page"},{"location":"security/#End-to-end-encryption","page":"Security","title":"End-to-end encryption","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"The broker requires that in the directoy $REMBUS_KEYSTORE there are:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The server certificate caronte.crt;\nThe private key caronte.key;","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component requires a CA bundle or the CA certificate of the authority that signed the broker certificate. The environment variable HTTP_CA_BUNDLE may be used to specify the the CA file.","category":"page"},{"location":"security/#Authentication","page":"Security","title":"Authentication","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"For enabling authentication a previsous exchange of a public key or a shared secret must be performed.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the secret material is not know to the broker then the connection phase skips the authentication steps and the named component connects but without any privilege reserved to authenticated and authorized components.  ","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"For a component with name foobar that connect to the broker the authentication mechanism involves the following steps.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component sends a message declaring the name foobar;\nIf exists the file $BROKER_DB/keys/foobar then the broker replies with a random challenge;\nThe component calculates a digest, if the the $REMBUS_DIR/keys/foobar file is a RSA private key:\nThen make a SHA256 digest of a string containing the challenge plus the name foobar and signs\nthe digest with the private key.\nOtherwise consider the file content as a shared secret and make a SHA256 digest\nof the string containing the challenge plus the shared secret.\nThe component send the digest to the broker;\nThe broker verifies the digest, if the the $BROKER_DIR/keys/foobar file is a RSA public key:\nVerify that the received digest of string containing the challenge plus the name foobar\nis signed by the corresponding private key;  \nOtherwise verify that the received digest equals to the digest of the string containing the\nchallenge plus the shared secret;\nIf authentication succeed a SUCCESS response is returned, otherwise ERROR is returned and the","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"connection is closed.","category":"page"},{"location":"security/#Authorization","page":"Security","title":"Authorization","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"By default topics are considered public, that is accessible by all components.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the topic is declared private then only authorized components may access it with the APIs:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"publish\nrpc\nexpose/unexpose\nsubscribe/unsubscribe","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The topic visibility may be changed by a component with admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"rb = connect(\"superuser\")\n\n# public -> private\nprivate_topic(rb, \"my_topic\")\n\n# private -> public\npublic_topic(rb, \"my_topic\")","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"To execute such actions the admin role must be assigned to the component superuser: its name must be present in the file $BROKER_DIR/admins.json","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"More then one component may be assigned the admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"# admis.json\n[\"superuser\", \"foobar\"]","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"","category":"page"},{"location":"brokerless/#Brokerless","page":"Brokerless","title":"Brokerless","text":"","category":"section"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"It is possible to use Rembus protocol to setup a simple architecture without a broker.","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"In this scenario one component plays the role of a server that handles RPC requests and receives messages published by others components.","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"In this scenario one component handles RPC requests and receives messages published by a component that connects directly to it.","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"NOTE Without a broker a pub/sub is a one-to-one communication pattern: one component","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"publishes a message that is received by the components that embeds the server.","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"Below a minimal example of a component that exposes a service and accepts connections for others components and respond only to authorized components:","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"using Rembus\n\nfunction my_service(session, x,y)\n    isauthorized(session) || error(\"unauthorized\")\n    return x+y\nend\n\nfunction start_server()\n    rb = embedded()\n    provide(rb, my_service)\n    serve(rb)\nend\n\nstart_server()\n","category":"page"},{"location":"brokerless/#Detailed-description","page":"Brokerless","title":"Detailed description","text":"","category":"section"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"The component that play the server role is initialized as:","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"rb = embedded()","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"Bind methods implementation to the server with provide:","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"provide(rb, mymethod)","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"Only the expose method is required in a brokeless context because the only difference between a rpc exposed method and a pub/sub subscribed method is that the first one replies a value to the rpc client.","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"This means that one expose API works in place of expose and subscribe APIs required for configuring a broker.","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"The signature of mymethod must have a session object as first argument. The session object may be useful for serving only authorized components with isauthorized(session).","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"For example if rpc method is invoked with two arguments:","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"@rpc myservice(x,y)","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"then the signature of mymethod must be:","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"function mymethod(session, x, y)\n    return x + y\nend","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"Finally step start the server and wait for ever for client connection requests:","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"Rembus.serve(rb)","category":"page"},{"location":"brokerless/","page":"Brokerless","title":"Brokerless","text":"","category":"page"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/#Broker-environment-variables","page":"Configuration","title":"Broker environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The broker setup is affected by the following environment variables.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nBROKER_DIR $HOME/.config/caronte Root dir for configuration files and cached messages to be delivered to offline components opting for retroactive mode\nBROKER_TCP_PORT 8000 use tls://<host>:$BROKER_TCP_PORT for serving TLS protocol\nBROKER_WS_PORT 8001 use wss://<host>:$BROKER_WS_PORT for serving WSS protocol\nBROKER_ZMQ_PORT 8002 ZeroMQ port zmq://<host>:$BROKER_ZMQ_PORT\nREMBUS_DEBUG 0 \"1\": enable debug traces\nREMBUS_KEYSTORE $BROKER_DIR/keystore Directory of broker certificate caronte.crt and broker secret key caronte.key","category":"page"},{"location":"configuration/#Component-environment-variables","page":"Configuration","title":"Component environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A Rembus component is affected by the following environement variables. ","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_DIR $HOME/.config/rembus Root dir for component configuration files\nREMBUS_BASE_URL ws://localhost:8000 Default base url when defining component with  a simple string instead of a complete url. @component \"myclient\" is equivalent to @component \"ws://localhost:8000/myclient\"\n##REMBUS_CA rembus-ca.crt CA certificate file name. This file has to be in $REMBUS_KEYSTORE directory\nREMBUS_DEBUG 0 \"1\": enable debug traces\n##REMBUS_KEYSTORE $REMBUS_DIR/keystore Directory of CA certificate\nREMBUS_TIMEOUT 5 Maximum number of seconds waiting for rpc responses\nHTTP_CA_BUNDLE $REMBUS_DIR/ca/rembus-ca.crt CA certificate\n##HTTP_CA_BUNDLE_OLD $REMBUS_KEYSTORE/$REMBUS_CA CA certificate","category":"page"},{"location":"configuration/#Broker-configuration-files","page":"Configuration","title":"Broker configuration files","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The directory BROKER_DIR contains broker settings and secret materials.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cd $BROKER_DIR\n> tree .\n\n.\n├── admins.json\n├── keys\n│   ├── bar\n│   └── foo\n├── exposers.json\n├── owners.csv\n├── component_owner.csv\n├── topic_auth.json\n├── twins\n    ├── bar\n    └── foo\n\n","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"where foo and bar are example component names.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"In case the component are offline the undelivered messages are temporarly persisted into twins/bar and /twins/foo files.","category":"page"},{"location":"configuration/#Admin-privileges","page":"Configuration","title":"Admin privileges","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"admins.json contains the list of components that have the admin role. The element of this list are component names.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat admins.json\n[\"foo\", \"bar\"]","category":"page"},{"location":"configuration/#RPC-exposers","page":"Configuration","title":"RPC exposers","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"exposers.json is a map with topic as keyword and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The topic keyword is the name of an RPC method exposed by all components present in the value array.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat exposers.json\n{\n    \"topic_1\":[\"foo\"],\n    \"topic_2\":[\"foo\", \"bar\"]\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"foo component exposes topic_1 and topic_2 rpc methods.\nbar component exposes topic_2 rpc method.","category":"page"},{"location":"configuration/#Pub/Sub-subscribers","page":"Configuration","title":"Pub/Sub subscribers","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The topics subscribers are persisted in the file subscribers.json. Only named component are persisted.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"subscribers.json contains a map: keywords are component names and values are maps. The keys of the map are subscribed topics and values are booleans that assert if the topic is retroactive:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat subscribers.json\n{\n    \"mycomponent\":{\"mytopic1\": true, \"mytopic2\": false}\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"mycomponent is subscribed to mytopic1 and mytopic2 topics, and mytopic1 is retroactive, namely when it connects it wants to receive messages published when it was offline.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For declaring retroactiveness with Supervised API use the option before_now:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"@subscribe mytopic1 before_now","category":"page"},{"location":"configuration/#Private-topics","page":"Configuration","title":"Private topics","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"topic_auth.json is a map with topic as keywords and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat topic_auth.json\n{\n    \"foo\":[\"myconsumer\",\"myproducer\"]\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"asserts then only components myconsumer and myproducer are allowed to bind to the topic foo.","category":"page"},{"location":"configuration/#Users-allowed-to-register-components","page":"Configuration","title":"Users allowed to register components","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Authenticated components may be provisioned with the register API method.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"register(component_name, uid, pin)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"register requires a username and a pin that must match with one of the entries of owners.csv file.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat owners.csv \npin,uid,name,enabled\n482dc7eb,paperoga@topolinia.com,Fethry Duck,false\n58e26283,paperino@topolinia.com,Donald Fauntleroy Duck,false","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The pin column is the PIN token needed for registration, uid column is the username, name is an optional string describing the user and enabled consent to stop the user for registering components.","category":"page"},{"location":"configuration/#Components-ownership","page":"Configuration","title":"Components ownership","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"component_owner.csv is a csv file containing the mapping between the registered components and the user that performed the registration with register API.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"uid is the user identity and component is the component identifier.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example if the user Paperoga registered the component foo then:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat component_owner.csv\nuid,component\npaperoga@topolinia.com,foo","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"fault_tolerance/#Fault-tolerance-features","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"section"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Beside struggling to provide a simple and lean API one of the main points of Rembus is its ability to be fault-tolerant respect to networks and application failures.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"The Supervised API provide an automatic reconnection policy in case of network faults and try at the best to guarantee message delivery when faults happen. ","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"This mean that the following RPC service will run forever and it will reconnect automatically in case of network failures or broker unavailability.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"mycomponent\"\n\nfunction myservice(input::DataFrame)\n    # run your super-cool logic and get back the result\n    output_df = my_logic(input)\n    return output_df\nend\n\n@expose myservice\n\nforever()","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Fault-tolerance holds equally for publish/subscribe setups: in case of connection lost the subscriber retries to reconnect to the broker until the connection will be up again.   ","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"If the subscription use the before_now option then messages published whereas the component was offline are delivered ordered by time of publishing when the component get online again.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"consumer\"\n\nfunction mytopic(input::DataFrame)\n    # consume the dataframe posted to mytopic topic\nend\n\n@subscribe mytopic before_now\n\nforever()","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"page"},{"location":"#Rembus","page":"Home","title":"Rembus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Rembus","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rembus is a middleware for Pub/Sub and RPC communication styles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two types of processes: Components and Brokers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Component connect to a Broker;\nA Broker dispatch messages between Components;\nA Component expose RPC services and/or subscribe to Pub/Sub topics;\nA Component make RPC requests and/or publish messages to Pub/Sub topics;","category":"page"},{"location":"#Broker","page":"Home","title":"Broker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Broker is a process that routes messages between components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Broker is capable of making components that use different transport protocols talk to each other. For example a component that uses a ZeroMQ socket may talk to a component that uses the WebSocket protocol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting a Broker is simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e \"using Rembus; caronte()\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"A startup script could be useful and the following caronte script suffice:","category":"page"},{"location":"","page":"Home","title":"Home","text":"##!/bin/bash\n#=\nBINDIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\nexec julia --threads auto --color=no -e \"include(popfirst!(ARGS))\" \\\n --project=$BINDIR/.. --startup-file=no \"${BASH_SOURCE[0]}\" \"$@\"\n=#\nusing Rembus\n\nRembus.caronte()","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Broker environment variables for customizing the runtime setting.  ","category":"page"},{"location":"#Component","page":"Home","title":"Component","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Component is a process that plays one or more of the following roles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Publisher (Pub/Sub) : produce messages;\nSubscriber (Pub/Sub): consume published messages;\nRequestor (RPC): request a service;\nExposer (RPC): execute a service request and give back a response;","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are three type of components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Anonymous\nNamed\nAuthenticated","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Anonymous component assume a random and ephemeral identity each time it connects to the broker. Example usage for anonymous components may be:","category":"page"},{"location":"","page":"Home","title":"Home","text":"when it is not required to trace the originating source of messages;\nfor a Subscriber when it is not required to receive messages published before the component goes online;\nfor preliminary prototyping;","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Named component has a unique and persistent name that make possible to receive messages published when the component was offline.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Authenticated component is a named component that own a private key or a shared secret which can prove its identity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Only authenticated components may use Pub/Sub private topics and private RPC methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An URL string defines the identity and the connection parameters of a component. The Supervised API page documents the URL format.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Rembus]","category":"page"},{"location":"#Rembus.RembusDisconnect","page":"Home","title":"Rembus.RembusDisconnect","text":"RembusDisconnect\n\nThrown when a rembus connection get unexpectedly down.\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RembusTimeout","page":"Home","title":"Rembus.RembusTimeout","text":"RembusTimeout\n\nThrown when a response it is not received.\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodException","page":"Home","title":"Rembus.RpcMethodException","text":"RpcMethodException\n\nThrown when a RPC method throws an exception.\n\nFields\n\ncid: component name\ntopic: service name\nreason: remote exception description\n\nExposer\n\n@expose foo(name::AbstractString) = \"hello \" * name\n\nRPC client\n\ntry\n    @rpc foo(1)\ncatch e\n    @error e.reason\nend\n\nOutput:\n\n┌ Error: MethodError: no method matching foo(::UInt64)\n│\n│ Closest candidates are:\n│   foo(!Matched::AbstractString)\n│    @ Main REPL[2]:1\n└ @ Main REPL\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodLoopback","page":"Home","title":"Rembus.RpcMethodLoopback","text":"RpcMethodLoopback\n\nThrown when a RPC request would invoke a locally exposed method.\n\nFields\n\ncid: component name\ntopic: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodNotFound","page":"Home","title":"Rembus.RpcMethodNotFound","text":"RpcMethodNotFound is thrown from a rpc request when the called method is unknown.\n\nfields:\n\ncid: component name\ntopic: service name\n\nRPC Client\n\n@rpc coolservice()\n\nOutput:\n\nERROR: Rembus.RpcMethodNotFound(\"rembus\", \"coolservice\")\nStacktrace:\n...\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodUnavailable","page":"Home","title":"Rembus.RpcMethodUnavailable","text":"RpcMethodUnavailable\n\nThrown when a RPC method is unavailable.\n\nA method is considered unavailable when some component that exposed the method is currently disconnected from the broker.\n\nFields\n\ncid: component name\ntopic: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.caronte-Tuple{}","page":"Home","title":"Rembus.caronte","text":"caronte(; wait=true, exit_when_done=true)\n\nStart the broker.\n\nReturn immediately when wait is false, otherwise blocks until shut down.\n\nReturn instead of exiting if exit_when_done is false.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.connect-Tuple{AbstractString}","page":"Home","title":"Rembus.connect","text":"connect(url::AbstractString)::RBHandle\n\nConnect to the broker.\n\nThe returned rembus handler do not auto-reconnect in case of a fault condition.\n\nThe returned RBHandle handle represents a connected component used for the Rembus APIs. For example:\n\nusing Rembus\nrb = connect(\"mycomponent\")\npublish(rb, \"temperature\", [\"room_1\", 21.5])\n\nThe url argument string is formatted as:\n\nurl = [<protocol>://][<host>][:<port>/]<cid>\n\n<protocol> is one of:\n\nws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket\n\n<host> and <port> are the hostname/ip and the port of the listening broker.\n\n<cid> is the unique name of the component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.connect-Tuple{}","page":"Home","title":"Rembus.connect","text":"connect()\n\nConnect anonymously to the endpoint declared with REMBUS_BASE_URL env variable.\n\nREMBUS_BASE_URL default to ws://127.0.0.1:8000\n\nA component is considered anonymous when a different and random UUID is used as component identifier each time the application connect to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.embedded-Tuple{}","page":"Home","title":"Rembus.embedded","text":"embedded()\n\nInitialize an embedded server for brokerless rpc and one way pub/sub.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.expose-Tuple{Rembus.RBHandle, AbstractString, Function}","page":"Home","title":"Rembus.expose","text":"expose(rb::RBHandle, fn::Function; exceptionerror=true)\nexpose(rb::RBHandle, topic::AbstractString, fn::Function; exceptionerror=true)\n\nExpose the methods of function fn to be executed by rpc clients using topic as RPC method name.\n\nIf the topic argument is omitted the function name equals to the RPC method name.\n\nfn returns the RPC response.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.forever-Tuple{Rembus.RBHandle}","page":"Home","title":"Rembus.forever","text":"forever(rb::RBHandle)\n\nStart the event loop awaiting to execute exposed and subscribed methods.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.isauthorized-Tuple{Any}","page":"Home","title":"Rembus.isauthorized","text":"isauthorized(session)\n\nReturn true if the connected component is authenticated.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.publish","page":"Home","title":"Rembus.publish","text":"publish(rb::RBHandle, topic::AbstractString, data=[])\n\nPublish data values on topic.\n\ndata may be a value or a vector of values. Each value map to the arguments of the subscribed method.\n\nFor example if the subscriber is a method that expects two arguments:\n\nmytopic(x,y) = @info \"x=$x, y=$y\"\n\nThe published message needs an array of two elements:\n\npublish(rb, \"mytopic\", [1, 2])\n\nWhen a subscribed method expect one argument instead of passing an array of one element it may be better to pass the value:\n\nmytopic(x) = @info \"x=$x\"\n\npublish(rb, \"mytopic\", 1)\n\nIf the subscribed method has no arguments invoke publish as:\n\nmytopic() = @info \"mytopic invoked\"\n\npublish(rb, \"mytopic\")\n\ndata array may contains any type, but if the components are implemented in different languages then data has to be a DataFrame or a primitive type that is CBOR encodable.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.reactive-Tuple{Rembus.RBHandle}","page":"Home","title":"Rembus.reactive","text":"reactive(rb::RBHandle, timeout=5; exceptionerror=true)\n\nStart the delivery of published messages for which there was declared an interest with subscribe.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.register-Tuple{AbstractString, AbstractString, AbstractString}","page":"Home","title":"Rembus.register","text":"register(cid::AbstractString, userid::AbstractString, pin::AbstractString)\n\nRegister the component with name cid.\n\nTo register a component a user must be provisioned in the owners.csv table.\n\nThe pin shared secret is a 8 hex digits string (for example \"deedbeef\").\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rpc","page":"Home","title":"Rembus.rpc","text":"rpc(rb::RBHandle,\n    topic::AbstractString,\n    data=nothing;\n    exceptionerror=true,\n    timeout=request_timeout())\n\nCall the remote topic method with arguments extracted from data.\n\nExposer\n\nusing Rembus\nusing Statistics\n\n@expose service_noargs() = \"success\"\n\n@expose service_name(name) = \"hello \" * name\n\n@expose service_dictionary(d) = mean(values(d))\n\n@expose function service_multiple_args(name, score, flags)\n    isa(name, String) && isa(score, Float64) && isa(flags, Vector)\nend\n\nRPC client\n\nusing Rembus\n\nrb = connect()\n\nrcp(rb, \"service_noargs\")\n\nrpc(rb, \"service_name\", \"hello world\")\n\nrpc(rb, \"service_dictionary\", Dict(\"r1\"=>13.3, \"r2\"=>3.0))\n\nrpc(rb, \"service_multiple_args\", [\"name\", 1.0, [\"red\"=>1,\"blue\"=>2,\"yellow\"=>3]])\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.serve-Tuple{Rembus.Embedded}","page":"Home","title":"Rembus.serve","text":"serve(embedded::Embedded; wait=true, exit_when_done=true, secure=false)\n\nStart an embedded server and accept connections.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.shared-Tuple{Rembus.RBHandle, Any}","page":"Home","title":"Rembus.shared","text":"shared(rb::RBHandle, ctx)\n\nBind a ctx context object to the rb component.\n\nWhen a ctx context object is bound then it will be the first argument of subscribed and exposed methods.\n\nSee @shared for more details.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.subscribe","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb::RBHandle, fn::Function, retroactive::Bool=false; exceptionerror=true)\nsubscribe(\n    rb::RBHandle, topic::AbstractString, fn::Function, retroactive::Bool=false;\n    exceptionerror=true\n)\n\nDeclare interest for messages published on topic logical channel.\n\nThe function fn is called when a message is received on topic and reactive put the rb component in reactive mode.\n\nIf the topic argument is omitted the function name must be equal to the topic name.\n\nIf retroactive is true then rb component will receive messages published when it was offline.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.unexpose-Tuple{Rembus.RBHandle, AbstractString}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb::RBHandle, fn::Function; exceptionerror=true)\nunexpose(rb::RBHandle, topic::AbstractString; exceptionerror=true)\n\nStop servicing RPC requests targeting topic or fn methods.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unreactive-Tuple{Rembus.RBHandle}","page":"Home","title":"Rembus.unreactive","text":"unreactive(rb::RBHandle, timeout=5; exceptionerror=true)\n\nStop the delivery of published message.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unregister-Tuple{Any, AbstractString}","page":"Home","title":"Rembus.unregister","text":"unregister(cid::AbstractString)\n\nUnregister the client identified by cid.\n\nThe secret pin is not needed because only an already connected and authtenticated component may execute the unregister command.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.RBHandle, AbstractString}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb::RBHandle, topic::AbstractString; exceptionerror=true)\nunsubscribe(rb::RBHandle, fn::Function; exceptionerror=true)\n\nNo more messages published on a topic logical channel or a topic name equals to the name of the subscribed function will be delivered to rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.@component-Tuple{Any}","page":"Home","title":"Rembus.@component","text":"@component \"url\"\n\nSet the name of the component and the protocol for connecting to the broker.\n\nurl may be:\n\n\"myname\": use $REMBUS_BASE_URL for connection parameters\n\"tcp://host:port/myname\": tcp connection\n\"ws://host:port/myname\": web socket connection\n\"zmq://host:port/myname\": ZeroMQ connection\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Expr}","page":"Home","title":"Rembus.@expose","text":"@expose function fn(arg1,...)\n    ...\nend\n\nExpose the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Symbol}","page":"Home","title":"Rembus.@expose","text":"@expose fn\n\nExpose all the methods of the function fn.\n\nExample\n\nExpose the function mycalc that implements a service that may accept two numbers or a string and number:\n\nmycalc(x::Number, y::Number) = x+y\nmycalc(x::String, y::Number) = length(x)*y\n\n@expose mycalc\n\nCall mycal service using the correct types of arguments:\n\n# ok\njulia> response = @rpc mycalc(1,2)\n0x0000000000000003\n\n# ok\njulia> response = @rpc mycalc(\"hello\",2.0)\n10.0\n\nIf the RPC client call mycalc with the argument's type that do not respect the signatures of the exposed service then it throws RpcMethodException\n\njulia> response = @rpc mycalc(\"hello\",\"world\")\nERROR: RpcMethodException(\"rembus\", \"mycalc\", \"MethodError: no method matching mycalc(::String, ::String) ...\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@forever-Tuple{}","page":"Home","title":"Rembus.@forever","text":"@forever\n\nStart the event loop awaiting to execute exposed and subscribed methods.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@publish-Tuple{Any}","page":"Home","title":"Rembus.@publish","text":"@publish topic(arg1,arg2,...)\n\nPublish a message to topic logic channel.\n\nThe function topic(arg1,arg2,...) will be called on each connected component subscribed to topic.\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\nSubscriber\n\nfunction foo(name, value)\n    println(\"do something with $name=$value\")\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@reactive","page":"Home","title":"Rembus.@reactive","text":"@reactive\n\nThe subscribed methods start to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc-Tuple{Any}","page":"Home","title":"Rembus.@rpc","text":"@rpc service(arg1,...)\n\nCall the remote service method and return its outcome.\n\nThe outcome may be the a return value or a RpcMethodException if the remote throws an exception.\n\nThe service method must match the signature of an exposed remote service method.\n\nComponents may subscribe to service for receiving the service request.\n\nExposer\n\nfunction mymethod(x, y)\n    return evaluate(x,y)\nend\n\n@expose mymethod\nsupervise()\n\nRPC client\n\nresponse = @rpc mymethod(x,y)\n\nSubscriber\n\nfunction service(x, y)\n    ...\nend\n\n@subscribe service\n@reactive\n\nsupervise()\n\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc_timeout-Tuple{Any}","page":"Home","title":"Rembus.@rpc_timeout","text":"@rpc_timeout value\n\nSet the rpc request timeout in seconds.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@shared-Tuple{Any}","page":"Home","title":"Rembus.@shared","text":" @shared container\n\nBind a container object that is passed as the first argument of the subscribed component functions.\n\nThe container is useful for mantaining a state.\n\nusing Rembus\n\n# keep the number of processed messages\nmutable struct Context\n    msgcount::UInt\nend\n\nfunction topic(context::Context, arg1, arg2)\n    context.msgcount += 1\n    some_logic(arg1, arg2)\nend\n\nctx = Context(0)\n@subscribe topic\n@shared ctx\n\nUsing @shared to set a container object means that if some component publish topic(arg1,arg2) then the method foo(container,arg2,arg2) will be called.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe","page":"Home","title":"Rembus.@subscribe","text":"@subscribe function fn(args...)\n    ...\nend [mode]\n\nSubscribe the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe-2","page":"Home","title":"Rembus.@subscribe","text":"@subscribe topic [mode]\n\nSetup a subscription to topic logic channel to handle messages from @publish or @rpc.\n\nmode values`:\n\nfrom_now (default): receive messages published from now.\nbefore_now: receive messages published when the component was offline.\n\nMessages starts to be delivered to topic when reactivity is enabled with @reactive macro.\n\nSubscriber\n\nfunction foo(arg1, arg2)\n    ...\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@terminate","page":"Home","title":"Rembus.@terminate","text":"@terminate\n\nClose the connection and terminate the component.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unexpose-Tuple{Symbol}","page":"Home","title":"Rembus.@unexpose","text":"@unexpose fn\n\nThe methods of fn function is no more available to rpc clients.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unreactive","page":"Home","title":"Rembus.@unreactive","text":"@unreactive\n\nThe subscribed methods stop to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unsubscribe-Tuple{Symbol}","page":"Home","title":"Rembus.@unsubscribe","text":"@unsubscribe mytopic\n\nThe methods of mytopic function stop to handle messages published to topic mytopic.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
