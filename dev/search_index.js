var documenterSearchIndex = {"docs":
[{"location":"api/#Rembus-API","page":"Component API","title":"Rembus API","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"This API provides both approaches to connection handling:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"automatic reconnection in case of network failures\nexception throwing in case of network errors and reconnection explicitly managed by the application.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Rembus API functions:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"component\nconnect\nexpose\nunexpose\nrpc\nsubscribe\nunsubscribe\npublish\nreactive\nunreactive\nwait\ninject\nclose\nshutdown","category":"page"},{"location":"api/#component","page":"Component API","title":"component","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Connect to the broker and return a Visor process handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"In case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = component(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The Macro-based API page documents the URL format.","category":"page"},{"location":"api/#connect","page":"Component API","title":"connect","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Connect to the broker and return a connection handle used by the other APIs for exchanging data and commands.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The URL string passed to connect contains the address of a broker, the transport protocol, the port and optionally a persistent unique name for the component.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect(\"ws://hostname:8000/mycomponent\")","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The Macro-based API page documents the URL format.","category":"page"},{"location":"api/#expose","page":"Component API","title":"expose","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\nexpose(rb, myservice)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The exposed function will became available to RPC clients using the @rpc macro or the rpc function.","category":"page"},{"location":"api/#unexpose","page":"Component API","title":"unexpose","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop serving remote requests via rpc or @rpc.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"unexpose(rb, myservice)","category":"page"},{"location":"api/#rpc","page":"Component API","title":"rpc","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"response = rpc(rb, \"my_service\", Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The service name and the arguments are CBOR-encoded and transported to the remote site and the method my_service that expects a Dict as argument is called. ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The return value of my_service is transported back to the RPC client calling site and taken as the return value of rpc.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the remote method throws an Exception then the local RPC client will throw either an Exception reporting the reason of the remote error.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the exposed method expects many arguments send an array of values, where each value is an argument:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"# exposer side\nfunction my_service(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\n    return x+y+z\nend\n\n# rpc client side\nrpc(rb, \"my_service\", [1, 2, 3])","category":"page"},{"location":"api/#subscribe","page":"Component API","title":"subscribe","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Declare interest for messages published on a logical channel: the topic.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\nrb = connect()\n\nsubscribe(rb, mytopic)\n\nwait(rb) # or until Ctrl-C ","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"By default subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the from argument set to LastReceived:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect(\"myname\")\n\nsubscribe(rb, mytopic, LastReceived)\n\nwait(rb) # or until Ctrl-C","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The subscribed function will be called each time a component produce a message with the@publish macro or the publish function.","category":"page"},{"location":"api/#unsubscribe","page":"Component API","title":"unsubscribe","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop the function to receive messages produced with publish or @publish.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"unsubscribe(rb, myservice)","category":"page"},{"location":"api/#publish","page":"Component API","title":"publish","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Publish a message:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"rb = connect()\n\npublish(rb, \"metric\", Dict(\"name\"=>\"trento/castello\", \"var\"=>\"T\", \"value\"=>21.0))\n\nclose(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"metric is the message topic and the Dict value is the message content.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"If the subscribed method expects many arguments send an array of values, where each value is an argument:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"# subscriber side\nfunction my_topic(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\nend\n\n# publisher side\npublish(rb, \"my_topic\", [1, 2, 3])","category":"page"},{"location":"api/#reactive","page":"Component API","title":"reactive","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"reactive(rb)","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"It is worth noting that the wait function enables the reactive mode.","category":"page"},{"location":"api/#unreactive","page":"Component API","title":"unreactive","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Stop receiving published messages.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"unreactive(rb)","category":"page"},{"location":"api/#wait","page":"Component API","title":"wait","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Needed for components that expose and/or subscribe methods. Wait forever for rpc requests or pub/sub messages.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"By default wait enable component reactiveness, see reactive.","category":"page"},{"location":"api/#inject","page":"Component API","title":"inject","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"inject is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"When a state is injected two additional arguments are passed to the subscribed/exposed methods:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"the first argument is the state value;\nthe second argument is the node handle;","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The following example shows how to use a shared state:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"the struct MyState manages the state;\nthe inject method binds the state object to the component;\nthe subscribed and the exposed method must declare as first argument the state object and as second argument the node handle;","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate::MyState, handle::RBHandle, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\nrb = connect(\"ingestor\")\ninject(rb, mystate)\n\n# declare interest to messages produced with\n# publish(rb, \"add_metric\", Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\nsubscribe(rb, add_metric) \n\n# implement a service that may be requested with\n# rpc(rb, \"fetch_metrics\")\nexpose(rb, fetch_metrics)\n\nwait(rb)","category":"page"},{"location":"api/#close","page":"Component API","title":"close","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Close the network connections associated with the rb handle and terminate the supervised processes related to the handle.","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"close(rb)","category":"page"},{"location":"api/#shutdown","page":"Component API","title":"shutdown","text":"","category":"section"},{"location":"api/","page":"Component API","title":"Component API","text":"Terminate all the active supervised processes:","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"shutdown()","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"The method shutdown(rb) is equivalent to close(rb).","category":"page"},{"location":"api/","page":"Component API","title":"Component API","text":"","category":"page"},{"location":"cheatsheet/#Rembus-Cheat-Sheet","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/#Startup-and-teardown","page":"Rembus Cheat Sheet","title":"Startup and teardown","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Connect to the broker with identity myname:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@component \"myname\"","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Close the connection and shutdown the component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@shutdown","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Loop unless Ctrl-C or shutdown():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"wait()","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: wait is required by @subscribe and @expose unless you are in the REPL.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Terminate background Rembus task and return from wait():","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"shutdown()","category":"page"},{"location":"cheatsheet/#Pub/Sub:-1-publisher-and-N-subscribers","page":"Rembus Cheat Sheet","title":"Pub/Sub: 1 publisher and N subscribers","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Publish a message with topic mytopic and data payload that is the CBOR encoding of [arg1, arg2, arg3]:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@publish mytopic(arg1, arg2, arg3)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Subscribe to topic mytopic, the arguments arg1, arg2, arg3 are the CBOR decoded values of the data payload:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"# Method `mytopic` is called for each published message.\nfunction mytopic(arg1, arg2, arg3)\n    # do something\nend\n\n# Two different modes of subscription:\n@subscribe mytopic from_now # declare interest to topic mytopic handling newer messages \n@subscribe mytopic before_now # messages from the past and not received because offline\n@subscribe mytopic # default to from_now  ","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Start and stop to call subscribed methods when a published message is received:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@reactive\n@reactive_off","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Remove the topic subscription:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unsubscribe mytopic","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"By default reactive in enabled.","category":"page"},{"location":"cheatsheet/#Remote-Procedure-Call","page":"Rembus Cheat Sheet","title":"Remote Procedure Call","text":"","category":"section"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Call the remote method myrpc exposed by a component:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"response = @rpc myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"NOTE: in case of successfull invocation the response value is the remote method return value, othervise an exception is thrown.","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Expose a method implementation:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"function myrpc(arg1, arg2)\n    # evaluate body and return response ...\n    return response\nend\n\n@expose myrpc(arg1, arg2)","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"Stop to serve the RPC method:","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"@unexpose myrpc","category":"page"},{"location":"cheatsheet/","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"page"},{"location":"http_api/#HTTP-Rest-API","page":"HTTP Rest API","title":"HTTP Rest API","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus offers an HTTP REST interface for RPC requests, Pub/Sub publishing and a set of broker administration commands.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"An HTTP endpoint must be explicity activated with the http options:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"bin/broker --http port","category":"page"},{"location":"http_api/#APIs-list","page":"HTTP Rest API","title":"APIs list","text":"","category":"section"},{"location":"http_api/#No-Auth-and-Basic-Auth-APIs","page":"HTTP Rest API","title":"No Auth and Basic Auth APIs","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET   http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/subscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/expose/{topic}/{cid}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{cid}","category":"page"},{"location":"http_api/#Basic-Auth-APIs","page":"HTTP Rest API","title":"Basic Auth APIs","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET   https://broker_host:port/admin/{command}\nPOST  https://broker_host:port/private_topic/{topic}\nPOST  https://broker_host:port/public_topic/{topic}\nPOST  https://broker_host:port/authorize/{cid}/{topic}\nPOST  https://broker_host:port/unauthorize/{cid}/{topic}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Basic-Auth is required to invoke a REST endpoint that requires client authentication:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Since Basic-Auth send the password unprotected it is strongly advised to use an encrypted https connection.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Basic-Auth POST example:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"basic_auth(str::String) = Base64.base64encode(str)\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.post(\n    \"https://127.0.0.1:9000/private_topic/my_topic\",\n    [\"Authorization\" => auth]\n)","category":"page"},{"location":"http_api/#RPC","page":"HTTP Rest API","title":"RPC","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The GET HTTP method used to make RPC requests has the following url template:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET http[s]://broker_host:port/{method_name}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"A RPC uses a GET verb because GET is used by default to request data from the server.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The return value is JSON encoded in the response body.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"For example, consider the following exposed methods by a server component:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using Rembus\n\n@expose greet(name) = \"hello $name\"\n@expose sum(x,y) = x + y","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Then the HTTP invocations by a client will be:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using HTTP\nusing JSON3\n\nsum_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/sum\", [], JSON3.write([1.0, 2.0])).body,\n    Any\n)\n\njulia_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write(\"Julia\")).body,\n    Any\n)\n\njane_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write([\"Jane\"])).body,\n    Any\n)","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The RPC GET method returns a HTTP status success 200 and the returned value in the response body if the method succeeds or a HTTP status 403 and an error description in the response body if the method fails.","category":"page"},{"location":"http_api/#Pub/Sub","page":"HTTP Rest API","title":"Pub/Sub","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The POST HTTP method used to publish a message has the following url template:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST http[s]://broker_host:port/{method_name}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The POST verb is used for Pub/Sub because by default its scope it is to send data to the server.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument, as in the case of RPC method.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The Pub/Sub POST method returns a HTTP status success 200 and an empty response body, if the method succeeds.","category":"page"},{"location":"http_api/#Subscribe-and-Expose-configuration-commands","page":"HTTP Rest API","title":"Subscribe and Expose configuration commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The REST APIS:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST  http[s]://broker_host:port/subscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/expose/{topic}/{component}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{component}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"may be used to configure in advance the \"routing\" tables of the broker, for example to to cache Pub/Sub messages for components that never connected to the broker but that in the future they will be interested to the topic messages.","category":"page"},{"location":"http_api/#Authorization-commands","page":"HTTP Rest API","title":"Authorization commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus topics come in two flawors:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"public topic accessible to all components.\nprivate topics accessible to authorized components.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The following REST commands set the privateness and authorize a component to access a private topic:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"POST https://broker_host:port/private_topic/{topic}\nPOST https://broker_host:port/authorize/{component}/{topic}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The HTTP header must contain a Basic-Auth property with a base64 encoded string component:password associated with a component with admin privilege.","category":"page"},{"location":"http_api/#Broker-administration-commands","page":"HTTP Rest API","title":"Broker administration commands","text":"","category":"section"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The REST admin command set broker properties or return the broker configuration.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"GET https://broker_host:port/admin/{command}","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"The following administrations command may be invoked:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"broker_config: return the components list that expose methods and subscribe to topics.\nenable_debug: set the broker log level to DEBUG.\ndisable_debug: disable the DEBUG log level.\nload_config: reload the broker config files from disk.\nsave_config: save the broker configuration to disk.\nshutdown: shutdown the broker.","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"For example the following set the broker log level to debug:","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"using Base64\nusing HTTP\n\nbasic_auth(str::String) = Base64.base64encode(str)\n\nadmin = \"admin\"\npassword = \"aaa\"\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.get(\n    \"http://127.0.0.1:9000/admin/enable_debug\",\n    [\"Authorization\" => auth]\n)","category":"page"},{"location":"http_api/","page":"HTTP Rest API","title":"HTTP Rest API","text":"","category":"page"},{"location":"security/#Security","page":"Security","title":"Security","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"End-to-end encryption is provided by Secure Web Socket (wss) and Transport Layer Security (tls) protocols.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"Authentication and authorization are realized by using RSA keys. The component owns a secret key and the broker knows its public key.","category":"page"},{"location":"security/#End-to-end-encryption","page":"Security","title":"End-to-end encryption","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"The broker requires that in the directoy $REMBUS_KEYSTORE there are:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The server certificate rembus.crt;\nThe private key rembus.key;","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component requires a CA bundle or the CA certificate of the authority that signed the broker certificate. The environment variable HTTP_CA_BUNDLE may be used to specify the the CA file.","category":"page"},{"location":"security/#Authentication","page":"Security","title":"Authentication","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"For enabling authentication a previsous exchange of a public key or a shared secret must be performed.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the secret material is not know to the broker then the connection phase skips the authentication steps and the named component connects but without any privilege reserved to authenticated and authorized components.  ","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"For a component with name foobar that connect to the broker the authentication mechanism involves the following steps.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The component sends a message declaring the name foobar;\nIf exists the file $BROKER_DB/keys/foobar then the broker replies with a random challenge;\nThe component calculates a digest, if the the $HOME/.config/rembus/keys/foobar file is a RSA private key:\nMake a SHA256 digest of a string containing the challenge plus the name foobar and signs the digest with the private key.\nOtherwise consider the file content as a shared secret and make a SHA256 digest of the string containing the challenge plus the shared secret.\nThe component send the digest to the broker;\nThe broker verifies the digest, if the the $HOME/.config/broker/keys/foobar file is a RSA public key:\nVerify that the received digest of string containing the challenge plus the name foobar is signed by the corresponding private key;  \nOtherwise verify that the received digest equals to the digest of the string containing the\nchallenge plus the shared secret;\nReturn SUCCESS if authentication succeed, otherwise return ERROR and close the connection.","category":"page"},{"location":"security/#Authorization","page":"Security","title":"Authorization","text":"","category":"section"},{"location":"security/","page":"Security","title":"Security","text":"By default topics are considered public, that is accessible by all components.","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"If the topic is declared private then only authorized components may access it with the methods:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"publish\nrpc\nexpose/unexpose\nsubscribe/unsubscribe","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"The topic visibility may be changed by a component with admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"rb = connect(\"superuser\")\n\n# public -> private\nprivate_topic(rb, \"my_topic\")\n\n# private -> public\npublic_topic(rb, \"my_topic\")","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"To execute such actions the admin role must be assigned to the component superuser: its name must be present in the file $HOME/.config/broker/admins.json","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"More then one component may be assigned the admin role:","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"# admis.json\n[\"superuser\", \"foobar\"]","category":"page"},{"location":"security/","page":"Security","title":"Security","text":"","category":"page"},{"location":"macro_api/#Macro-based-API","page":"Macro-based API","title":"Macro-based API","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The supervised API uses the metaprogramming features of Julia and provides an high level interface that make easy to integrate distributed components.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The goal of this API is to make easy developing robust and fault-tolerant distributed applications.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The following macros comprise the API and enable Julia to be supercharged with the capabilities of a middleware for RPC and Pub/Sub messaging:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component\n@expose\n@unexpose\n@rpc\n@subscribe\n@unsubscribe\n@publish\n@reactive\n@unreactive\n@wait\n@inject\n@wait","category":"page"},{"location":"macro_api/#component","page":"Macro-based API","title":"component","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"A component needs to know the address of a broker, the transport protocol, the port and optionally it has to declare a persistent unique name for the component.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"These settings are defined with a URL string:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"component_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"\n\n@component component_url","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<protocol> is one of:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"ws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<host> and <port> are the hostname/ip and the port of the listening broker.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"<cid> is the unique name of the component. If it is not defined create an anonymous component.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For example:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"ws://broker.org:8000/myclient\"","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"defines the component myclient that communicates with the broker hosted on broker.org, listening on port 8000 and accepting web socket connections.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"NOTE Rembus is \"lazy\": declaring a component does not open a connection to the broker. The connection will be opened when first needed.","category":"page"},{"location":"macro_api/#Default-component-URL-parameters","page":"Macro-based API","title":"Default component URL parameters","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The URL string may be simplified by using the enviroment variable REMBUS_BASE_URL.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Setting for example REMBUS_BASE_URL=ws://localhost:8000 the above component_url may be simplified as:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"myclient\"","category":"page"},{"location":"macro_api/#expose","page":"Macro-based API","title":"expose","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Take a Julia function and exposes all of its the methods.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"function myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\n@expose myservice","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The exposed function will became available to RPC clients using the @rpc macro.","category":"page"},{"location":"macro_api/#unexpose","page":"Macro-based API","title":"unexpose","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop serving remote requests with @rpc requests.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unexpose myservice","category":"page"},{"location":"macro_api/#rpc","page":"Macro-based API","title":"rpc","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Request a remote method and wait for a response.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"response = @rpc myservice(Dict(\"name\"=>\"foo\", \"tickets\"=>3))","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The arguments of the local function call myservice is transported to the remote site and myservice method expecting a Dict as argument is executed. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The return value of myservice is transported back to the RPC client calling site and @rpc returns.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"If the remote method throws an Exception then the local RPC client throws an Exception reporting the reason of the remote error.","category":"page"},{"location":"macro_api/#subscribe","page":"Macro-based API","title":"subscribe","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Declare interest for messages published on a logical channel that usually is called topic.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The subscribed Julia methods are named as the topic of interest. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"function mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\n@subscribe mytopic\n\nwait() # or until Ctrl-C ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default @subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"For receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the option before_now:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@component \"myname\"\n\n@subscribe mytopic before_now\n\n@wait # or until Ctrl-C","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"NOTE By design messages are not persisted until a component declares","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"interest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"page"},{"location":"macro_api/#unsubscribe","page":"Macro-based API","title":"unsubscribe","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop the function to receive messages produced with @publish.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unsubscribe myservice","category":"page"},{"location":"macro_api/#publish","page":"Macro-based API","title":"publish","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Publishing a message is like calling a local function named as the pub/sub topic. ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@publish mytopic(1.2, 3.0)","category":"page"},{"location":"macro_api/#reactive","page":"Macro-based API","title":"reactive","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Enable the reception of published messages from subscribed topics.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@reactive","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Reactiveness is a property of a component and is applied to all subscribed topics.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default a component starts with reactive mode enabled.","category":"page"},{"location":"macro_api/#unreactive","page":"Macro-based API","title":"unreactive","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Stop receiving published messages.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@unreactive","category":"page"},{"location":"macro_api/#wait","page":"Macro-based API","title":"wait","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Needed for components that expose and/or subscribe methods. Wait forever for rpc requests or pub/sub messages.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"By default @wait enable component reactiveness, see @reactive.","category":"page"},{"location":"macro_api/#inject","page":"Macro-based API","title":"inject","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@inject is handy when a state must be shared between the subscribed methods, the exposed methods and the application.","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"When a state is injected two additional arguments are passed to the subscribed/exposed methods:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"the first argument is the state value;\nthe second argument is the node handle;","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"The following example shows how to use a inject state:","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"the struct MyState manages the state;\nthe @inject macro binds the state object to the component;\nthe subscribed and the exposed method must declare as first argument the state object and as second argument the node handle;","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"mutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate::MyState, rb::RBHandle, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\n@component \"ingestor\"\n@inject mystate\n\n# declare interest to messages produced with\n# @publish add_metric(Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\n@subscribe add_metric \n\n# implement a service that may be requested with\n# @rpc fetch_metrics()\n@expose fetch_metrics\n\n@wait","category":"page"},{"location":"macro_api/#wait-2","page":"Macro-based API","title":"wait","text":"","category":"section"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"Close the network connection and shutdown the supervised process associated with the component.   ","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"@wait","category":"page"},{"location":"macro_api/","page":"Macro-based API","title":"Macro-based API","text":"","category":"page"},{"location":"brokerless/#Client-Server-architecture","page":"Client-Server","title":"Client-Server architecture","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"It is possible to use Rembus protocol to setup a simple client-server architecture without a decoupling broker.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"In this scenario one component plays the role of a server that handles RPC requests and receives messages published by others components that play the role of clients.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"NOTE Without a broker a pub/sub is a one-to-one communication pattern: components publish messages that are received by the server but they are not broadcasted to anyone else.","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"Below a minimal example of a component that exposes a service and accepts connections for others components and respond only to authenticated components:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"using Rembus\n\nfunction my_service(ctx, component, x, y)\n    ## authorization barrier \n    # isauthenticated(component) || error(\"unauthorized\")\n    return x+y\nend\n\nfunction start_server()\n    rb = server()\n    expose(rb, my_service)\n    wait(rb)\nend\n\nstart_server()","category":"page"},{"location":"brokerless/#Detailed-description","page":"Client-Server","title":"Detailed description","text":"","category":"section"},{"location":"brokerless/#The-Server","page":"Client-Server","title":"The Server","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The component that plays the server role is initialized as:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"rb = server()","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"expose, as usual,  make methods available to RPC clients:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"expose(rb, my_service)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The signature of my_service must have a ctx value as first argument and a component value as second argument:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"function mymethod(ctx, component, x, y)\n    return x + y\nend","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The ctx argument is a global state object that is passed to the server constructor:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"mutable struct Ctx\n    # state fields\nend\n\nctx = Ctx()\n\nrb = server(ctx)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"If a global state is not needed by default ctx is set to nothing:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"rb = server()\nexpose(rb, \"my_service\")\n\n#implies that ctx is nothing:\nfunction my_function(ctx, component, x, y)\n    @assert ctx === nothing\nend","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"The component object if useful for:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"serving only authenticated components;\nstoring component session state into session(component) dictionary;","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"wait is the final step: the server starts and waits for connection requests from clients:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"Rembus.wait(rb)","category":"page"},{"location":"brokerless/#The-Client","page":"Client-Server","title":"The Client","text":"","category":"section"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"On the calling side the rpc method has to be invoked with two arguments:","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"@rpc my_service(x,y)","category":"page"},{"location":"brokerless/","page":"Client-Server","title":"Client-Server","text":"","category":"page"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/#Broker-environment-variables","page":"Configuration","title":"Broker environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The broker setup is affected by the following environment variables.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_DIR $HOME/.config/rembus data root directory\nBROKER_WS_PORT 8000 default port for serving WebSocket protocol\nREMBUS_DEBUG  \"1\": enable debug traces\nREMBUS_KEYSTORE $REMBUS_ROOT_DIR/keystore Directory of broker/server certificate rembus.crt and broker/server secret key rembus.key","category":"page"},{"location":"configuration/#Component-environment-variables","page":"Configuration","title":"Component environment variables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A Rembus component is affected by the following environment variables.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Variable Default Descr\nREMBUS_DIR $HOME/.config/rembus data root directory\nREMBUS_BASE_URL ws://localhost:8000 Default base url when defining component with  a simple string instead of a complete url. @component \"myclient\" is equivalent to @component \"ws://localhost:8000/myclient\"\nREMBUS_DEBUG  \"1\": enable debug traces\nREMBUS_TIMEOUT 5 Maximum number of seconds waiting for rpc responses\nHTTP_CA_BUNDLE $REMBUS_ROOT_DIR/ca/rembus-ca.crt CA certificate","category":"page"},{"location":"configuration/#Broker-configuration-files","page":"Configuration","title":"Broker configuration files","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The broker name determines the directory where the data files are stored.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example, to set the name of the broker with the companion broker script use the optional name argument:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"broker --name my_broker","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"In the following it is assumed the default broker name for the broker: in this case the directory $REMBUS_DIR/broker contains the broker settings and secret materials.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cd ~/.config/rembus/broker\n> tree .\n\n.\n admins.json\n keys\n  bar.rsa.pem\n  foo.ecdsa.pem\n exposers.json\n tenants.json\n component_owner.json\n topic_auth.json\n twins.json\n messages\n   1345\n   345456\n   867687\n","category":"page"},{"location":"configuration/#Secret-material-for-authenticated-components","page":"Configuration","title":"Secret material for authenticated components","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A file in the keys directory contains the secret material used to authenticate the component.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"This file may contain:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"a RSA public key;\nan ECDSA public key;\na plaintext shared password string;","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"To create the RSA or ECDSA  key pairs and send the public key to the broker the Rembus.register method may be employed.","category":"page"},{"location":"configuration/#Components-with-admin-privilege","page":"Configuration","title":"Components with admin privilege","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"admins.json contains the list of components that have the admin role. The element of this list are component names.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat admins.json\n[\"foo\", \"bar\"]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"A component with admin privilege may change the privateness level of topics and authorize other components to bind to private topics.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"See private_topic, public_topic, authorize, unauthorize for details.","category":"page"},{"location":"configuration/#RPC-exposers","page":"Configuration","title":"RPC exposers","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"exposers.json is a map with topic as keyword and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The topic keyword is the name of an RPC method exposed by all components present in the value array.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat exposers.json\n{\n    \"topic_1\":[\"foo\"],\n    \"topic_2\":[\"foo\", \"bar\"]\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"foo component exposes topic_1 and topic_2 rpc methods.\nbar component exposes topic_2 rpc method.","category":"page"},{"location":"configuration/#Pub/Sub-subscribers","page":"Configuration","title":"Pub/Sub subscribers","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The topics subscribers are persisted in the file subscribers.json. Only named component are persisted.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"subscribers.json contains a map: keywords are component names and values are maps. The keys of the map are subscribed topics and values are floats that define time periods in microseconds. A message received before the node subscription time but included in the time period will be delivered to the node.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example, in the following setting mytopic1 does not get messages received before the subscription because the time period is zero, while messages more recent than one hour are delivered to topic2:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If the time period is Inf then all messages received before the time of subscription and not delivered because the node was offline are sent to it.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat subscribers.json\n{\n    \"mycomponent\":{\"mytopic1\": 0.0, \"mytopic2\": 3.6e9}\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For declaring interest for all messaged delivered wheh the node was offline with Macro-based API use from=LastReceived expression:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"@subscribe mytopic1 from=LastReceived","category":"page"},{"location":"configuration/#Private-topics","page":"Configuration","title":"Private topics","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"topic_auth.json is a map with topic as keywords and an array of component names as values.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"> cat topic_auth.json\n{\n    \"foo\":[\"myconsumer\",\"myproducer\"]\n}","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"asserts then only components myconsumer and myproducer are allowed to bind to the topic foo.","category":"page"},{"location":"configuration/#Users-allowed-to-register-components","page":"Configuration","title":"Users allowed to register components","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Authenticated components may be provisioned with the Rembus.register method.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"register(component_name, uid, pin, key_type=SIG_RSA)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"key_type may be equal to SIG_RSA for RSA Encryption and equal to SIG_ECDSA for Elliptic Curve Digital Signature Algorithm.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"register requires a tenant and a pin that must match with one of the users defined in tenants.json file. ","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenants.json file example:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[\n    {\n        \"tenant\": \"A\",\n        \"pin\": \"482dc7eb\",\n        \"enabled\": true\n    },\n    {\n        \"tenant\": \"B\",\n        \"pin\": \"58e26283\",\n    },\n\n]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant is the tenant identifier.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"pin is a secret token used for authentication. The pin column is a 8 digits string  composed of numbers and the characters [a-f]. ","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"enabled consent to disable the tenant and this does not allow to register new components.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"enabled is optional and if not present it defaults to true.","category":"page"},{"location":"configuration/#Components-ownership","page":"Configuration","title":"Components ownership","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant_component.json contains the mapping between the registered component and the tenant to which it belong.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tenant is the tenant identifier and component is the component identifier.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"For example if the tenant A registered the component foo then tenant_component.json  will be:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"[\n    {\"tenant\": \"A\",\"component\": \"foo\"}    \n]","category":"page"},{"location":"configuration/#Files-reserved-to-the-broker","page":"Configuration","title":"Files reserved to the broker","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"twins.json get saved at broker shutdown and contains, for each component, the reference for the last message delivered to the component. It is a file managed by the broker, do no edit this file.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"the files in messages directory are parquet files that get saved periodically and at broker shutdown and contain all the published messages.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"fault_tolerance/#Fault-tolerance-features","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"section"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Beside struggling to provide a simple and lean API one of the main points of Rembus is its ability to be fault-tolerant respect to networks and application failures.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"The Macro-based API and the component method provide an automatic reconnection policy in case of network faults and try at the best to guarantee message delivery when faults happen.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"This mean that the following RPC service will run forever and it will reconnect automatically in case of network failures or broker unavailability.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"mycomponent\"\n\nfunction myservice(input::DataFrame)\n    # run your super-cool logic and get back the result\n    output_df = my_logic(input)\n    return output_df\nend\n\n@expose myservice\n\n@wait","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Fault-tolerance holds equally for publish/subscribe setups: in case of connection lost the subscriber retries to reconnect to the broker until the connection will be up again.   ","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"If the subscription use the before_now option then messages published whereas the component was offline are delivered ordered by time of publishing when the component get online again.","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"using Rembus\n\n@component \"consumer\"\n\nfunction mytopic(input::DataFrame)\n    # consume the dataframe posted to mytopic topic\nend\n\n@subscribe mytopic before_now\n\n@wait","category":"page"},{"location":"fault_tolerance/","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"","category":"page"},{"location":"#Rembus","page":"Home","title":"Rembus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Rembus","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rembus is a middleware for Pub/Sub and RPC communication styles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Rembus node may play one o more roles: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"RPC client\nRPC server\nPub/Sub publisher \nPub/Sub subscriber\nBroker","category":"page"},{"location":"","page":"Home","title":"Home","text":"This meshup of roles enables a to implements a set of distributed architectures. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Rembus\")","category":"page"},{"location":"#Broker","page":"Home","title":"Broker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Broker is a process that routes messages between components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Broker is capable of making components that use different transport protocols talk to each other. For example a component that uses a ZeroMQ socket may talk to a component that uses the WebSocket protocol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting a Broker is simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Rembus\n\nbroker()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Calling broker without arguments start by default a WebSocket server listening on port 8000.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A startup script could be useful and the following broker script will do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"#!/bin/bash\n#=\nSDIR=$( dirname -- \"${BASH_SOURCE[0]}\" )\nBINDIR=$( cd -- $SDIR &> /dev/null && pwd )\nexec julia -t auto --color=no -e\"include(popfirst!(ARGS))\" \\\n --project=$BINDIR/.. --startup-file=no \"${BASH_SOURCE[0]}\" \"$@\"\n=#\nusing ArgParse\nusing Rembus\n\nfunction command_line(default_name=\"broker\")\n    s = ArgParseSettings()\n    @add_arg_table! s begin\n        \"--name\", \"-n\"\n        help = \"broker name\"\n        default = default_name\n        arg_type = String\n        \"--reset\", \"-r\"\n        help = \"factory reset, clean up broker configuration\"\n        action = :store_true\n        \"--secure\", \"-s\"\n        help = \"accept wss and tls connections\"\n        action = :store_true\n        \"--authenticated\", \"-a\"\n        help = \"only authenticated components allowed\"\n        action = :store_true\n        \"--http\", \"-p\"\n        help = \"accept HTTP clients on port HTTP\"\n        arg_type = UInt16\n        \"--prometheus\", \"-m\"\n        help = \"prometheus exposer port\"\n        arg_type = UInt16\n        \"--ws\", \"-w\"\n        help = \"accept WebSocket clients on port WS\"\n        arg_type = UInt16\n        \"--tcp\", \"-t\"\n        help = \"accept tcp clients on port TCP\"\n        arg_type = UInt16\n        \"--zmq\", \"-z\"\n        help = \"accept zmq clients on port ZMQ\"\n        arg_type = UInt16\n        \"--policy\"\n        help = \"set the broker routing policy\"\n        arg_type = Symbol\n        \"--debug\", \"-d\"\n        help = \"enable debug logs\"\n        action = :store_true\n        \"--info\", \"-i\"\n        help = \"enable info logs\"\n        action = :store_true\n    end\n    return parse_args(s)\nend\n\nargs = command_line()\nname = args[\"name\"]\nif args[\"reset\"]\n    Rembus.broker_reset(name)\nend\n\nif args[\"debug\"]\n    Rembus.debug!()\nelseif args[\"info\"]\n    Rembus.info!()\nend\n\nwait(Rembus.broker(\n    name=name,\n    ws=args[\"ws\"],\n    tcp=args[\"tcp\"],\n    zmq=args[\"zmq\"],\n    prometheus=args[\"prometheus\"],\n    authenticated=args[\"authenticated\"]\n))\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"broker starts by default a WebSocket server listening on port 8000, for enabling tcp and/or zmq transports use the appropriate arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"shell> ./broker\nusage: broker [-r] [-s] [-p HTTP] [-w WS] [-t TCP] [-z ZMQ] [-d] [-h]\n\noptional arguments:\n  -r, --reset      factory reset, clean up broker configuration\n  -s, --secure     accept wss and tls connections\n  -p, --http HTTP  accept HTTP clients on port HTTP (type: UInt16)\n  -w, --ws WS      accept WebSocket clients on port WS (type: UInt16)\n  -t, --tcp TCP    accept tcp clients on port TCP (type: UInt16)\n  -z, --zmq ZMQ    accept zmq clients on port ZMQ (type: UInt16)\n  -d, --debug      enable debug logs\n  -h, --help       show this help message and exit","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Broker environment variables for customizing the runtime setting.  ","category":"page"},{"location":"#Component","page":"Home","title":"Component","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Component is a process that plays one or more of the following roles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Publisher (Pub/Sub) : produce messages;\nSubscriber (Pub/Sub): consume published messages;\nRequestor (RPC): request a service;\nExposer (RPC): execute a service request and give back a response;","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are three type of components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Anonymous\nNamed\nAuthenticated","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Anonymous component assume a random and ephemeral identity each time it connects to the broker. Example usage for anonymous components may be:","category":"page"},{"location":"","page":"Home","title":"Home","text":"when it is not required to trace the originating source of messages;\nfor a Subscriber not interested to receive messages published when it was offline;\nfor preliminary prototyping;","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Named component has a unique and persistent name that make possible to receive messages published when the component was offline.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Authenticated component is a named component that own a private key or a shared secret which can prove its identity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Only authenticated components may use Pub/Sub private topics and private RPC methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An URL string defines the identity and the connection parameters of a component. The Macro-based API page documents the URL format.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Rembus]","category":"page"},{"location":"#Rembus.RembusError","page":"Home","title":"Rembus.RembusError","text":"struct RembusError <: Rembus.RembusException\n\nGeneric Rembus error.\n\nFields\n\ncode::UInt8: error code\ntopic::Union{Nothing, String}: topic name if available\nreason::Union{Nothing, String}: detailed error message\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RembusTimeout","page":"Home","title":"Rembus.RembusTimeout","text":"struct RembusTimeout{T} <: Rembus.RembusException\n\nException thrown when a response is not received before the request timeout expires.\n\nFields\n\nmsg::Any: request message\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodException","page":"Home","title":"Rembus.RpcMethodException","text":"struct RpcMethodException <: Rembus.RembusException\n\nThrown when a RPC method throws an exception.\n\nFields\n\ntopic::String: service name\nreason::String: remote exception description\n\nExample\n\nA component exposes a method that expect a string argument.\n\n@expose foo(name::AbstractString) = \"hello \" * name\n\nA RPC client invoke the method with an integer argument.\n\ntry\n    @rpc foo(1)\ncatch e\n    @error e.reason\nend\n\nThe result is an exception:\n\n Error: MethodError: no method matching foo(::UInt64)\n\n Closest candidates are:\n   foo(!Matched::AbstractString)\n    @ Main REPL[2]:1\n @ Main REPL\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodLoopback","page":"Home","title":"Rembus.RpcMethodLoopback","text":"struct RpcMethodLoopback <: Rembus.RembusException\n\nThrown when a RPC request would invoke a locally exposed method.\n\nFields\n\ntopic::String: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodNotFound","page":"Home","title":"Rembus.RpcMethodNotFound","text":"struct RpcMethodNotFound <: Rembus.RembusException\n\nException thrown from a rpc request when the called method is unknown.\n\nFields\n\ntopic::String: service name\n\nExample\n\nAn RPC Client request a method that does not exist.\n\n@rpc coolservice()\n\nThe result is an exception:\n\nERROR: Rembus.RpcMethodNotFound(\"rembus\", \"coolservice\")\nStacktrace:\n...\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodUnavailable","page":"Home","title":"Rembus.RpcMethodUnavailable","text":"struct RpcMethodUnavailable <: Rembus.RembusException\n\nThrown when a RPC method is unavailable.\n\nA method is considered unavailable when some component that exposed the method is currently disconnected from the broker.\n\nFields\n\ntopic::String: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.authorize-Tuple{Rembus.Twin, AbstractString, AbstractString}","page":"Home","title":"Rembus.authorize","text":"function authorize(rb, client::AbstractString, topic::AbstractString)\n\nAuthorize the client component to use the private topic.\n\nThe component must have the admin role for granting topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.broker","page":"Home","title":"Rembus.broker","text":"broker(; <keyword arguments>)\n\nStart a broker node and return a handle for interacting with it.\n\nThe broker acts as a central node to manage routing of RPC requests and Pub/Sub messages between nodes.\n\nIt supports multiple communication protocols (WebSocket, TCP, and ZMQ) and allows for customizable security, authentication, and routing policies.\n\nKeyword arguments\n\nname::AbstractString=\"broker\": The unique identifier for the broker supervisor process.\nws=nothing: The WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: The TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: The ZMQ Router listening port. Set to nothing to disable.\nprometheus=nothing: The Prometheus port for scraping monitoring metrics. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\npolicy::String=\"first_up\": The routing policy used when topics are served by multiple  nodes. Possible options include:\n\"first_up\": Selects the first connected node from the list of nodes exposing the RPC method.\n\"round_robin\": Distributes requests evenly across nodes in a round-robin fashion.\n\"less_busy\": Chooses the node with fewer outstanding requests.\nDefault Behavior\nIf ws, tcp, and zmq are all set to nothing, the broker will default to listening   for WebSocket connections on port 8000.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.component-Tuple{AbstractString}","page":"Home","title":"Rembus.component","text":"component(url::AbstractString; <keyword arguments>)\n\nStart a component node and return a handle for interacting with it.\n\nIn case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.\n\nThe url argument specifies the connection details for the component. For example, the URL ws://127.0.0.1:8000/foo specifies:\n\nProtocol: ws (WebSocket). Other supported protocols: wss, tcp, tls, zmq.\nAddress: 127.0.0.1 (localhost).\nPort: 8000.\nComponent Name: foo.\n\nAnonymous connections omit the path part of the URL.\n\nIf not specified, Rembus considers the above values as the default values.\n\nThis means the URL ws://127.0.0.1:8000/foo is equivalent to simply foo.\n\nAdditionally, a component may listen for incoming connections on configured ports, enabling it to act as a broker. These ports are specified using keyword arguments.\n\nKeyword Arguments\n\nname=missing: Unique string identifier for the component's supervisor process. Defaults to the path part of the url argument if missing.\nws=nothing: WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: ZMQ Router listening port. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\npolicy::String=\"first_up\": The routing policy used when topics are served by multiple  nodes. Options:\n\"first_up\": Selects the first connected node from the list of nodes exposing the RPC method.\n\"round_robin\": Distributes requests evenly across nodes in a round-robin fashion.\n\"less_busy\": Chooses the node with fewer outstanding requests.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.component-Tuple{Vector}","page":"Home","title":"Rembus.component","text":"component(urls::Vector)\n\nStart a component that connects to a pool of nodes defined by the urls array.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.do_connect-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.do_connect","text":"do_connect(twin::Twin)\n\nConnect to the endpoint declared with REMBUS_BASE_URL env variable.\n\nREMBUS_BASE_URL default to ws://127.0.0.1:8000\n\nA component is considered anonymous when a different and random UUID is used as component identifier each time the application connect to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.expose-Tuple{Rembus.Twin, AbstractString, Function}","page":"Home","title":"Rembus.expose","text":"expose(rb, topic::AbstractString, fn::Function)\nexpose(rb, fn::Function)\n\nExpose the methods of function fn to be executed by rpc clients using topic as RPC method name.\n\nIf the topic argument is omitted the function name equals to the RPC method name.\n\nfn returns the RPC response.\n\nExpose the methods of function fn to be invoked by RPC clients, using topic as the RPC method name.\n\nIf the topic argument is omitted, the function name is used as the RPC method name.\n\nfn is expected to return the RPC response. Any exceptions thrown by fn are caught and returned as an RPC exception.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.get_private_topics-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.get_private_topics","text":"get_private_topics(rb)\n\nReturn a dictionary mapping private topics to their lists of authorized components.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.ifdown_block-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.ifdown_block","text":"ifdown_block(rb)\n\n\nBlock rpc and publish calls until the twin is connected to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.inject","page":"Home","title":"Rembus.inject","text":"inject(rb, ctx)\n\nBind a ctx context to the rb component.\n\nWhen a ctx context is bound, the method signatures of subscribed and exposed functions change as follows:\n\nthe first argument is the ctx context.\nthe second argument is the rb component.\nThe remaining arguments correspond to the RPC request's arguments.\n\nThe ctx is useful for maintaining local state contextualized to the rb component.\n\nExample\n\nusing Rembus\n\n# keep the number of processed messages\nmutable struct Context\n    msgcount::UInt\nend\n\nfunction topic(context::Context, rb, arg1, arg2)\n    context.msgcount += 1\n    some_logic(arg1, arg2)\nend\n\nctx = Context(0)\nrb = component(\"myname\")\nsubscribe(rb, topic)\ninject(rb, ctx)\n\nIn this example, when a message is published:\n\npublish(rb, \"topic\", arg1, arg2)\n\nThe invoked method will receive the context and component as the first two arguments:\n\nfoo(container, rb, arg2, arg2)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.isauthenticated-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.isauthenticated","text":"isauthenticated(rb)\n\nReturn true if the component is authenticated.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.private_topic-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.private_topic","text":"private_topic(rb, topic::AbstractString)\n\nSet the specified topic to private.\n\nThe component must have the admin role to change the privacy level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.public_topic-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.public_topic","text":"public_topic(rb, topic::AbstractString)\n\nSet the specified topic to public.\n\nThe component must have the admin role to change the privacy level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.publish-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.publish","text":"publish(rb, topic::AbstractString, data...; qos=Rembus.QOS0)\n\nPublish (Vararg) data values to a specified topic.\n\nEach item in data is mapped to an argument of the remote method subscribed to the topic.\n\nThe data values can be of any type. However, if the components are implemented in different languages, the values must be either DataFrames or primitive types that are CBOR-encodable (see RFC 8949) for interoperability.\n\nThe keywork argument qos defines the quality of service (QoS) for message delivery. Possible values:\n\nRembus.QOS0 (default): At most one message is delivered to the subscriber (message may be lost).\nQOS1: At least one message is delivered to the subscriber (message may be duplicated).\nRembus.QOS2: Exactly one message is delivered to the subscriber.\n\nExamples\n\nIf the subscriber is a method that expects two arguments:\n\nmytopic(x, y) = ...  # do something with x and y\n\nYou can publish a message with (Vararg) data consisting of two values:\n\nrb = component(\"myname\")\npublish(rb, \"mytopic\", 1, 2)\n\nIf the remote subscribed method has no arguments invoke publish as:\n\npublish(rb, \"mytopic\")\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.reactive","page":"Home","title":"Rembus.reactive","text":"reactive(rb, from::Union{Real,Period,Dates.CompoundPeriod}=Day(1))\n\nEnable the reception of published messages for topics to which the node is subscribed via subscribe.\n\nThe from argument specifies the starting point in time from which messages published while the component was offline will be delivered upon reconnection.\n\nThis value applies to all subscribed topics but can be overridden by the from argument in the subscribe method for a specific topic  though only to define narrower time ranges.\n\nPossible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.\n\nExample\n\nrb = component(\"myname\")\nsubscribe(rb, \"mytopic1\", Rembus.Now)\nsubscribe(rb, \"mytopic2\", Rembus.LastReceived)\nsubscribe(rb, \"mytopic3\", Hour(1))\n\nreactive(rb, Day(1))\n\nIn this example:\n\nmytopic1 will receive messages starting from now.\nmytopic2 will receive messages published within the last day, even if subscribe()    uses Rembus.LastReceived.\nmytopic3 will receive messages published within the last hour.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.register-Tuple{AbstractString, AbstractString}","page":"Home","title":"Rembus.register","text":"register(\n    cid::AbstractString,\n    pin::AbstractString;\n    tenant=Union{Nothing, AbstractString} = nothing,\n    scheme::UInt8\n)\n\nRegister the component with name cid.\n\nTo register a component a single pin or a set of tenants must be configured in the tenants.json file.\n\nThe pin shared secret is a 8 hex digits string (for example \"deedbeef\").\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout!-Tuple{Real}","page":"Home","title":"Rembus.request_timeout!","text":"request_timeout!(value::Real)\n\nSet the default request timeout used when creating new nodes with the broker, component, connect, or server functions.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout!-Tuple{Rembus.Twin, Real}","page":"Home","title":"Rembus.request_timeout!","text":"request_timeout!(rb, value::Real)\n\nSet the request timeout value for the component rb.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.request_timeout","text":"request_timeout(rb)\n\nGet the request timeout value for the component rb.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout-Tuple{}","page":"Home","title":"Rembus.request_timeout","text":"request_timeout()\n\nReturns the default request timeout used when creating new nodes with the broker, component, connect, or server functions.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rid-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.rid","text":"rid(rb)\n\n\nReturn the identifier of the component (Rembus IDentifier).\n\nrb = component(\"ws://myhost.org:8000/myname\")\nrid(rb) === \"myname\"\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rpc-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.rpc","text":"rpc(rb, service::AbstractString, data...)\n\nMake a request for a remote service method using Vararg data values as method arguments.\n\nReturn a value or throw an error if a request timeout occurs or the remotely invoked method throws an exception.\n\nExample\n\nrb = component(\"myclient\")\n# invoke mysum(1, 2) on the remote site\nresult = rpc(rb, \"mysum\", 1, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.server-Tuple{}","page":"Home","title":"Rembus.server","text":"server(; <keyword arguments>)\n\nStart a server node and return a handle for interacting with it.\n\nThe server accepts connection from client nodes.\n\nIt supports multiple communication protocols (WebSocket, TCP, and ZMQ) and allows for customizable security and authentication.\n\nKeyword arguments\n\nname::AbstractString=\"broker\": The unique identifier for the server supervisor process.\nws=nothing: The WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: The TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: The ZMQ Router listening port. Set to nothing to disable.\nprometheus=nothing: The Prometheus port for scraping monitoring metrics. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\n\nDefault Behavior\n\nIf ws, tcp, and zmq are all set to nothing, the broker will default to listening for WebSocket connections on port 8000.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.start_broker-Tuple{Any}","page":"Home","title":"Rembus.start_broker","text":"start_broker(;\n    wait=true,\n    secure=nothing,\n    ws=nothing,\n    tcp=nothing,\n    zmq=nothing,\n    http=nothing,\n    prometheus=nothing,\n    name=\"broker\",\n    authenticated=false,\n    reset=nothing,\n    plugin=nothing,\n    context=nothing\n)\n\nStart the node.\n\nReturn immediately when wait is false, otherwise blocks until shutdown is requested.\n\nOverwrite command line arguments if args is not empty.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.subscribe","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb, topic::AbstractString, fn::Function, from=Rembus.Now)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.subscribe-2","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb, fn::Function, from=Rembus.Now)\n\nSubscribe to messages published to a topic and register a callback function fn to handle incoming messages.\n\nIf the topic argument is omitted, the function name must be equal to the topic name.\n\nThe from (default=Rembus.Now) argument defines the starting point in time from which messages published while the component was offline will be sent upon reconnection. Possible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.\n\nExample\n\nrb = component(\"myname\")\n\n# Define a callback function for the \"mytopic\" topic\nfunction mytopic(data)\n    println(\"Received: \", data)\nend\n\n# Subscribe to \"mytopic\", receiving only new messages from now\nsubscribe(rb, mytopic, from=Rembus.Now)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.unauthorize-Tuple{Rembus.Twin, AbstractString, AbstractString}","page":"Home","title":"Rembus.unauthorize","text":"function unauthorize(rb, client::AbstractString, topic::AbstractString)\n\nRevoke authorization to the client component for use of the private topic.\n\nThe component must have the admin role for revoking topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb, service::AbstractString)\n\nStop servicing RPC requests targeting service.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.Twin, Function}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb, fn::Function)\n\nStop servicing RPC requests targeting fn function.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unreactive-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.unreactive","text":"unreactive(rb)\n\nStops the delivery of published messages to the rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unregister-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.unregister","text":"unregister(twin)\n\nUnregister the connected component.\n\nOnly a connected and authenticated component may execute the unregister command.\n\nusing Rembus\n\ntwin = connect(\"authenticated_component\")\nRembus.unregister(twin)\nclose(twin)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb, topic::AbstractString)\n\nStops delivering messages published on the specified topic to the rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.Twin, Function}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb, fn::Function)\n\nStops delivering messages to the specified fn function.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.@component-Tuple{Any}","page":"Home","title":"Rembus.@component","text":"@component \"url\"\n\nSet the name of the component and the protocol for connecting to the broker.\n\nurl may be:\n\n\"myname\": use $REMBUS_BASE_URL for connection parameters\n\"tcp://host:port/myname\": tcp connection\n\"ws://host:port/myname\": web socket connection\n\"zmq://host:port/myname\": ZeroMQ connection\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Expr}","page":"Home","title":"Rembus.@expose","text":"@expose function fn(arg1,...)\n    ...\nend\n\nExpose the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Symbol}","page":"Home","title":"Rembus.@expose","text":"@expose fn\n\nExpose all the methods of the function fn.\n\nExample\n\nExpose the function mycalc that implements a service that may accept two numbers or a string and number:\n\nmycalc(x::Number, y::Number) = x+y\nmycalc(x::String, y::Number) = length(x)*y\n\n@expose mycalc\n\nCall mycal service using the correct types of arguments:\n\n# ok\njulia> response = @rpc mycalc(1,2)\n0x0000000000000003\n\n# ok\njulia> response = @rpc mycalc(\"hello\",2.0)\n10.0\n\nIf the RPC client call mycalc with the argument's type that do not respect the signatures of the exposed service then it throws RpcMethodException\n\njulia> response = @rpc mycalc(\"hello\",\"world\")\nERROR: RpcMethodException(\"rembus\", \"mycalc\", \"MethodError: no method matching mycalc(::String, ::String) ...\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@inject-Tuple{Any}","page":"Home","title":"Rembus.@inject","text":" @inject container\n\nBinds a container object, which is passed as the first argument to subscribed component functions.\n\nSee inject for more details.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@publish","page":"Home","title":"Rembus.@publish","text":"@publish topic(arg1,arg2,...)\n\nPublish a message to topic logic channel.\n\nThe function topic(arg1,arg2,...) will be called on each connected component subscribed to topic.\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\nSubscriber\n\nfunction foo(name, value)\n    println(\"do something with $name=$value\")\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@reactive","page":"Home","title":"Rembus.@reactive","text":"@reactive\n\nThe subscribed methods start to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc-Tuple{Any}","page":"Home","title":"Rembus.@rpc","text":"@rpc service(arg1,...)\n\nCall the remote service method and return its outcome.\n\nThe outcome may be the a return value or a RpcMethodException if the remote throws an exception.\n\nThe service method must match the signature of an exposed remote service method.\n\nComponents may subscribe to service for receiving the service request.\n\nExposer\n\nfunction mymethod(x, y)\n    return evaluate(x,y)\nend\n\n@expose mymethod\nsupervise()\n\nRPC client\n\nresponse = @rpc mymethod(x,y)\n\nSubscriber\n\nfunction service(x, y)\n    ...\nend\n\n@subscribe service\n@reactive\n\nsupervise()\n\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe","page":"Home","title":"Rembus.@subscribe","text":"@subscribe topic [mode]\n\nSetup a subscription to topic logic channel to handle messages from @publish or @rpc.\n\nmode values`:\n\nfrom_now (default): receive messages published from now.\nbefore_now: receive messages published when the component was offline.\n\nMessages starts to be delivered to topic when reactivity is enabled with @reactive macro.\n\nSubscriber\n\nfunction foo(arg1, arg2)\n    ...\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe-2","page":"Home","title":"Rembus.@subscribe","text":"@subscribe function fn(args...)\n    ...\nend [mode]\n\nSubscribe the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unexpose-Tuple{Any}","page":"Home","title":"Rembus.@unexpose","text":"@unexpose fn\n\nThe methods of fn function is no more available to rpc clients.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unreactive-Tuple{}","page":"Home","title":"Rembus.@unreactive","text":"@unreactive\n\nThe subscribed methods stop to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unsubscribe-Tuple{Any}","page":"Home","title":"Rembus.@unsubscribe","text":"@unsubscribe mytopic\n\nmytopic's methods stop to handle messages published to topic mytopic.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@wait-Tuple{}","page":"Home","title":"Rembus.@wait","text":"@wait\n\nBlock forever waiting for Ctrl-C/InterruptException or root supervisor shutdown.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
