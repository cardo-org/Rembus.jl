var documenterSearchIndex = {"docs":
[{"location":"json-rpc/#JSON-RPC","page":"JSON-RPC","title":"JSON-RPC","text":"Rembus supports the JSON-RPC 2.0 specification.\n\nTo enable JSON-RPC interaction an HTTP endpoint must be explicity activated with the http option:\n\nbin/broker --http 9000\n\nThis starts an HTTP server on port 9000. The root endpoint accepts JSON-RPC POST requests.","category":"section"},{"location":"json-rpc/#RPC","page":"JSON-RPC","title":"RPC","text":"In a JSON-RPC request:\n\nmethod: a string identifying the remote procedure (an exposed Rembus service).\nparams (optional): structured arguments, provided either\nby position as an Array, or\nby name as an Object.\nid: required for requests expecting a response. The response object will  contain the same id value.","category":"section"},{"location":"json-rpc/#Example:-Positional-Parameters","page":"JSON-RPC","title":"Example: Positional Parameters","text":"Consider a service subtract that expects two positional arguments:\n\nusing Rembus\n\n@expose subtract(x, y) = x - y\n\nA valid JSON-RPC request would use an Array for params:\n\ncurl -X POST http://localhost:9000 -H \"Content-Type: application/json\" -d '{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subtract\",\n  \"params\": [42, 23],\n  \"id\":2\n}'\n\nResponse:\n\n{\n  \"jsonrpc\":\"2.0\",\n  \"result\":19,\n  \"id\":2\n}","category":"section"},{"location":"json-rpc/#Example:-Named-Parameters","page":"JSON-RPC","title":"Example: Named Parameters","text":"If the service expects keyword arguments:\n\nusing Rembus\n\n@expose subtract(;x, y) = x - y\n\nThen params must be an Object:\n\ncurl -X POST http://localhost:9000 -H \"Content-Type: application/json\" -d '{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subtract\",\n  \"params\": {\"x\":23, \"y\":42},\n  \"id\":2\n}'\n\nResponse:\n\n{\n  \"jsonrpc\":\"2.0\",\n  \"result\":-19,\n  \"id\":2\n}","category":"section"},{"location":"json-rpc/#Example:-Error-Response","page":"JSON-RPC","title":"Example: Error Response","text":"If the RPC call fails (e.g., missing required parameters), the response includes an error object:\n\ncurl -X POST http://localhost:9000 -H \"Content-Type: application/json\" -d '{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subtract\",\n  \"params\": {\"x\":23},\n  \"id\":2\n}'\n\nResponse:\n\n{\n  \"jsonrpc\":\"2.0\",\n  \"error\":{\n      \"message\":\"UndefKeywordError(:y)\",\n      \"code\":-32000\n  },\n  \"id\":2\n}","category":"section"},{"location":"json-rpc/#Pub/Sub","page":"JSON-RPC","title":"Pub/Sub","text":"In JSON-RPC, a Notification is a Request object without an id field. Rembus uses this form to represent publish/subscribe messages.\n\nFor example, consider a subscriber function:\n\nusing Rembus\n\nmytopic(val) = println(\"mytopic recv: $val\")  \n\nrb = component(\"my_node\")\nsubscribe(rb, mytopic)\nreactive(rb)\n\nYou can publish a message to the topic mytopic with a JSON-RPC Notification:\n\ncurl -X POST http://localhost:9000 -H \"Content-Type: application/json\" -d '{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"mytopic\",\n  \"params\": [\"hello world\"]\n}'\n\nThis will print:\n\nmytopic recv: hello world\n\n","category":"section"},{"location":"api/#Rembus-API","page":"Component API","title":"Rembus API","text":"This API provides both approaches to connection handling:\n\nautomatic reconnection in case of network failures\nexception throwing in case of network errors and reconnection explicitly managed by the application.\n\nRembus API functions:\n\ncomponent\nconnect\nexpose\nunexpose\nrpc\nsubscribe\nunsubscribe\npublish\nput\nreactive\nunreactive\nwait\ninject\nclose\nshutdown","category":"section"},{"location":"api/#component","page":"Component API","title":"component","text":"component(\n    url::AbstractString;\n    ws=nothing,\n    tcp=nothing,\n    zmq=nothing,\n    name=missing,\n    secure=false,\n    authenticated=false,\n    policy=\"first_up\",\n    enc=Rembus.CBOR,\n    failovers=[]\n) -> Twin\n\n# for more details\nhelp?> component\n\nStart a component and join the network of Rembus nodes.","category":"section"},{"location":"api/#Connected-Component","page":"Component API","title":"Connected Component","text":"rb = component(\"ws://hostname:8000/mycomponent\")\n\nConnect to a broker that listens at the connection point ws://hostname:8000 and return the rb handle used by the other APIs for exchanging data and commands.\n\nIn case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.\n\nSee Component for URL format details.","category":"section"},{"location":"api/#Broker","page":"Component API","title":"Broker","text":"rb = component(ws=8000, tcp=8001)\n\nStart a broker that listens on the web socket port 8000 and on the TCP port 8001. The broker will accept connections from other components.","category":"section"},{"location":"api/#Broker-and-Connected-Component","page":"Component API","title":"Broker and Connected Component","text":"This is an advanced pattern that allows to create a component that is also a broker and that is able to connect to another broker. This pattern is useful for creating a component that is able to act as a proxy between two brokers or to create a component that is able to connect to a broker and at the same time to act as a broker for other components.\n\nrb = component(\"ws://hostname:8000/mycomponent\", ws=9000)\n\nStart a broker that listens on the WebSocket port 9000 and connect to a broker defined at the connection point ws://hostname:8000.","category":"section"},{"location":"api/#connect","page":"Component API","title":"connect","text":"connect(url::AbstractString) -> Twin\n\nConnect to the broker and return a connection handle used by the other APIs for exchanging data and commands.\n\nThe URL string passed to connect contains the address of a broker, the transport protocol, the port and optionally a persistent unique name for the component.\n\nA disconnection from the remote endpoint will not trigger automatic reconnection, for example:\n\nrb = connect(\"ws://hostname:8000/mycomponent\")\n\nConnects to a broker that listens at the connection point ws://hostname:8000 and returns the rb handle used by the other APIs for exchanging data and commands.\n\nIf the broker is not reachable the connect function will throw an Exception and if the connection is lost at a later time the rb handle becomes disconnected. The status of a component can be checked with the isopen  method:\n\nisopen(rb)","category":"section"},{"location":"api/#expose","page":"Component API","title":"expose","text":"expose(rb, name::AbstractString, fn::Function)\nexpose(rb, fn::Function)\n\nTake a Julia function and exposes all of its the methods.\n\nfunction myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\nexpose(rb, myservice)\n\nThe exposed function will became available to RPC clients using the @rpc macro or the rpc function.","category":"section"},{"location":"api/#unexpose","page":"Component API","title":"unexpose","text":"unexpose(rb, topic::AbstractString)\nunexpose(rb, fn::Function)\n\nStop serving remote requests via rpc or @rpc.","category":"section"},{"location":"api/#rpc","page":"Component API","title":"rpc","text":"rpc(\n    rb::Twin,\n    service::AbstractString,\n    data...\n)\n\n# for more details\nhelp?> rpc\n\nRequest a remote method and wait for a response.\n\nresponse = rpc(rb, \"my_service\", Dict(\"name\"=>\"foo\", \"tickets\"=>3))\n\nThe service name and the arguments are CBOR-encoded and transported to the remote site and the method my_service that expects a Dict as argument is called.\n\nThe return value of my_service is transported back to the RPC client calling site and taken as the return value of rpc.\n\nIf the remote method throws an Exception then the local RPC client will throw either an Exception reporting the reason of the remote error.\n\nIf the exposed method expects many arguments send an array of values, where each value is an argument:\n\n# exposer side\nfunction my_service(x,y,z)\n    @assert x == 1\n    @assert y == 2\n    @assert z == 3\n    return x+y+z\nend\n\n# rpc client side\nrpc(rb, \"my_service\", [1, 2, 3])","category":"section"},{"location":"api/#subscribe","page":"Component API","title":"subscribe","text":"subscribe(rb, topic::AbstractString, fn::Function, from=Rembus.Now)\n\nsubscribe(rb, fn::Function, from=Rembus.Now)\n\n# for more details\nhelp?> subscribe\n\nDeclare interest for messages published on the topic logical channel.\n\nIf the topic is not specified the function fn is subscribed to the topic of the same name of the function.\n\nThe subscribed function will be called each time a component produce a message with the@publish macro or the publish function.\n\nTo enable the reception of published messages, reactive must be called.\n\nfunction mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\nrb = connect()\n\nsubscribe(rb, mytopic)\n\nreactive(rb) \n\nThe from (default=Rembus.Now) argument defines the starting point in time from which messages published while the component was offline will be sent upon reconnection. Possible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.","category":"section"},{"location":"api/#Example","page":"Component API","title":"Example","text":"rb = connect(\"myname\")\n\nsubscribe(rb, mytopic, Rembus.LastReceived)\n\nreactive(rb) \n\nReceive all messages published since the last component disconnection.","category":"section"},{"location":"api/#unsubscribe","page":"Component API","title":"unsubscribe","text":"unsubscribe(rb::Twin, topic::AbstractString)\nunsubscribe(rb::Twin, fn::Function)\n\nStop the function to receive messages produced with publish or @publish.","category":"section"},{"location":"api/#publish","page":"Component API","title":"publish","text":"publish(rb::Twin, topic::AbstractString, data...; qos=Rembus.QOS0)\n\nPublish one or more data values to a topic.\n\nEach element in data is passed as an argument to the remote method subscribed to topic.\n\nThe data arguments may be of any type. For interoperability across components implemented in different languages, the values should be either DataFrames or primitive types that are CBOR-encodable (see RFC 8949).\n\nThe keyword argument qos specifies the quality of service (QoS) for message delivery:\n\nRembus.QOS0 (default): At most once delivery. A message may be delivered  zero or one time.\nRembus.QOS1: At least once delivery. A message is delivered one or more times.\nRembus.QOS2: Exactly once delivery. A message is delivered once and only once.","category":"section"},{"location":"api/#Examples","page":"Component API","title":"Examples","text":"If the subscriber is a method that expects two arguments:\n\nmytopic(x, y) = ...  # do something with x and y\n\nYou can publish a message with two data values::\n\nrb = component(\"myname\")\npublish(rb, \"mytopic\", 1, 2)\n\nIf the remote subscribed method has no arguments, publish without data:\n\npublish(rb, \"mytopic\")","category":"section"},{"location":"api/#put","page":"Component API","title":"put","text":"put(rb::Twin, topic::AbstractString, data...; qos=Rembus.QOS0)\n\nPublish one or more data values to a channel identified by topic, which is automatically prefixed with the component name.\n\nEach element in data is passed as an argument to the remote method subscribed to topic.\n\nThe data arguments may be of any type. For interoperability across components implemented in different languages, the values should be either DataFrames or primitive types that are CBOR-encodable (see RFC 8949).\n\nThe keyword argument qos specifies the quality of service (QoS) for message delivery:\n\nRembus.QOS0 (default): At most once delivery. A message may be delivered  zero or one time.\nRembus.QOS1: At least once delivery. A message is delivered one or more times.\nRembus.QOS2: Exactly once delivery. A message is delivered once and only once.","category":"section"},{"location":"api/#Example-2","page":"Component API","title":"Example","text":"rb = component(\"myname\")\nput(rb, \"mytopic\", 1, 2)\n\nThis publishes the values 1 and 2 to the topic myname/mytopic.","category":"section"},{"location":"api/#reactive","page":"Component API","title":"reactive","text":"reactive(\n    rb::Twin,\n    from::Union{Real,Period,Dates.CompoundPeriod}=Day(1),\n)\n\n# for more details\nhelp?> reactive\n\nEnable the reception of published messages from subscribed topics.\n\nReactiveness is a property of a component and is applied to all subscribed topics.","category":"section"},{"location":"api/#unreactive","page":"Component API","title":"unreactive","text":"unreactive(rb::Twin)\n\nStop receiving published messages.","category":"section"},{"location":"api/#wait","page":"Component API","title":"wait","text":"wait(rb::Twin)\n\nNeeded for components that expose and/or subscribe  methods. Wait forever for rpc requests or pub/sub messages.","category":"section"},{"location":"api/#inject","page":"Component API","title":"inject","text":"inject(rb::Twin, state::Any)\n\nBind a state object to the component.\n\ninject is handy when a state must be shared between the subscribed methods, the exposed methods and the application.\n\nWhen a state is injected two additional arguments are passed to the subscribed/exposed methods:\n\nthe first argument is the state value;\nthe second argument is the node handle;\n\nThe following example shows how to use a shared state:\n\nthe struct MyState manages the state;\nthe inject method binds the state object to the component;\nthe subscribed and the exposed method must declare as first argument the state object and as second argument the node handle;\n\nmutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate::MyState, handle::RBHandle, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\nrb = connect(\"ingestor\")\ninject(rb, mystate)\n\n# declare interest to messages produced with\n# publish(rb, \"add_metric\", Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\nsubscribe(rb, add_metric) \n\n# implement a service that may be requested with\n# rpc(rb, \"fetch_metrics\")\nexpose(rb, fetch_metrics)\n\nwait(rb)","category":"section"},{"location":"api/#close","page":"Component API","title":"close","text":"close(rb::Twin)\n\nClose the network connections associated with the rb handle and terminate the supervised processes related to the handle.\n\nclose(rb)","category":"section"},{"location":"api/#shutdown","page":"Component API","title":"shutdown","text":"shutdown(rb::Twin)\n\nTerminate all the active supervised processes: The method shutdown(rb) is equivalent to close(rb).\n\n","category":"section"},{"location":"cheatsheet/#Rembus-Cheat-Sheet","page":"Rembus Cheat Sheet","title":"Rembus Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/#Startup-and-teardown","page":"Rembus Cheat Sheet","title":"Startup and teardown","text":"Connect to the broker with identity myname:\n\n@component \"myname\"\n\nClose the connection and shutdown the component:\n\n@shutdown\n\nLoop unless Ctrl-C or shutdown():\n\nwait()\n\nNOTE: wait is required by @subscribe and @expose unless you are in the REPL.\n\nTerminate background Rembus task and return from wait():\n\nshutdown()","category":"section"},{"location":"cheatsheet/#Pub/Sub:-1-publisher-and-N-subscribers","page":"Rembus Cheat Sheet","title":"Pub/Sub: 1 publisher and N subscribers","text":"Publish a message with topic mytopic and data payload that is the CBOR encoding of [arg1, arg2, arg3]:\n\n@publish mytopic(arg1, arg2, arg3)\n\nSubscribe to topic mytopic, the arguments arg1, arg2, arg3 are the CBOR decoded values of the data payload:\n\n# Method `mytopic` is called for each published message.\nfunction mytopic(arg1, arg2, arg3)\n    # do something\nend\n\n# Two different modes of subscription:\n@subscribe mytopic from_now # declare interest to topic mytopic handling newer messages \n@subscribe mytopic before_now # messages from the past and not received because offline\n@subscribe mytopic # default to from_now  \n\nStart and stop to call subscribed methods when a published message is received:\n\n@reactive\n@reactive_off\n\nRemove the topic subscription:\n\n@unsubscribe mytopic\n\nBy default reactive in enabled.","category":"section"},{"location":"cheatsheet/#Remote-Procedure-Call","page":"Rembus Cheat Sheet","title":"Remote Procedure Call","text":"Call the remote method myrpc exposed by a component:\n\nresponse = @rpc myrpc(arg1, arg2)\n\nNOTE: in case of successfull invocation the response value is the remote method return value, othervise an exception is thrown.\n\nExpose a method implementation:\n\nfunction myrpc(arg1, arg2)\n    # evaluate body and return response ...\n    return response\nend\n\n@expose myrpc(arg1, arg2)\n\nStop to serve the RPC method:\n\n@unexpose myrpc\n\n","category":"section"},{"location":"http_api/#HTTP-Rest-API","page":"HTTP Rest API","title":"HTTP Rest API","text":"Rembus offers an HTTP REST interface for RPC requests, Pub/Sub publishing and a set of broker administration commands.\n\nAn HTTP endpoint must be explicity activated with the http options:\n\nbin/broker --http port","category":"section"},{"location":"http_api/#APIs-list","page":"HTTP Rest API","title":"APIs list","text":"The API endpoints may be grouped in two categories:\n\nNo Auth and Basic Auth APIs\nBasic Auth APIs\n\nThe requests that modify the broker configuration require a Basic-Auth header with a base64 encoded string admin:password associated with a component with admin privilege.","category":"section"},{"location":"http_api/#No-Auth-and-Basic-Auth-APIs","page":"HTTP Rest API","title":"No Auth and Basic Auth APIs","text":"GET   http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/{method_name}\nPOST  http[s]://broker_host:port/subscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{cid}\nPOST  http[s]://broker_host:port/expose/{topic}/{cid}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{cid}","category":"section"},{"location":"http_api/#Basic-Auth-APIs","page":"HTTP Rest API","title":"Basic Auth APIs","text":"GET   https://broker_host:port/admin/{command}\nPOST  https://broker_host:port/private_topic/{topic}\nPOST  https://broker_host:port/public_topic/{topic}\nPOST  https://broker_host:port/authorize/{cid}/{topic}\nPOST  https://broker_host:port/unauthorize/{cid}/{topic}\n\nSince Basic-Auth send the password unprotected it is strongly advised to use an encrypted https connection.\n\nBasic-Auth POST example:\n\nbasic_auth(str::String) = Base64.base64encode(str)\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.post(\n    \"https://127.0.0.1:9000/private_topic/my_topic\",\n    [\"Authorization\" => auth]\n)","category":"section"},{"location":"http_api/#RPC","page":"HTTP Rest API","title":"RPC","text":"The GET HTTP method used to make RPC requests has the following url template:\n\nGET http[s]://broker_host:port/{method_name}\n\nA RPC uses a GET verb because GET is used by default to request data from the server.\n\nThe body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument.\n\nThe return value is JSON encoded in the response body.\n\nFor example, consider the following exposed methods by a server component:\n\nusing Rembus\n\n@expose greet(name) = \"hello $name\"\n@expose sum(x,y) = x + y\n\nThen the HTTP invocations by a client will be:\n\nusing HTTP\nusing JSON3\n\nsum_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/sum\", [], JSON3.write([1.0, 2.0])).body,\n    Any\n)\n\njulia_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write(\"Julia\")).body,\n    Any\n)\n\njane_response = JSON3.read(\n    HTTP.get(\"http://localhost:9000/greet\", [], JSON3.write([\"Jane\"])).body,\n    Any\n)\n\nThe RPC GET method returns a HTTP status success 200 and the returned value in the response body if the method succeeds or a HTTP status 403 and an error description in the response body if the method fails.","category":"section"},{"location":"http_api/#Pub/Sub","page":"HTTP Rest API","title":"Pub/Sub","text":"The POST HTTP method used to publish a message has the following url template:\n\nPOST http[s]://broker_host:port/{method_name}\n\nThe POST verb is used for Pub/Sub because by default its scope it is to send data to the server.\n\nThe body of the request is the JSON formatted list of arguments expected by the remote method or a JSON formatted value if the remote method expect a single argument, as in the case of RPC method.\n\nThe Pub/Sub POST method returns a HTTP status success 200 and an empty response body, if the method succeeds.","category":"section"},{"location":"http_api/#Subscribe-and-Expose-configuration-commands","page":"HTTP Rest API","title":"Subscribe and Expose configuration commands","text":"The REST APIS:\n\nPOST  http[s]://broker_host:port/subscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/unsubscribe/{topic}/{component}\nPOST  http[s]://broker_host:port/expose/{topic}/{component}\nPOST  http[s]://broker_host:port/unexpose/{topic}/{component}\n\nmay be used to configure in advance the \"routing\" tables of the broker, for example to to cache Pub/Sub messages for components that never connected to the broker but that in the future they will be interested to the topic messages.","category":"section"},{"location":"http_api/#Authorization-commands","page":"HTTP Rest API","title":"Authorization commands","text":"Rembus topics come in two flawors:\n\npublic topic accessible to all components.\nprivate topics accessible to authorized components.\n\nThe following REST commands set the privateness and authorize a component to access a private topic:\n\nPOST https://broker_host:port/private_topic/{topic}\nPOST https://broker_host:port/authorize/{component}/{topic}\n\nThe HTTP header must contain a Basic-Auth property with a base64 encoded string component:password associated with a component with admin privilege.","category":"section"},{"location":"http_api/#Broker-administration-commands","page":"HTTP Rest API","title":"Broker administration commands","text":"The REST admin command set broker properties or return the broker configuration.\n\nGET https://broker_host:port/admin/{command}\n\nThe following administrations command may be invoked:\n\nbroker_config: return the components list that expose methods and subscribe to topics.\nenable_debug: set the broker log level to DEBUG.\ndisable_debug: disable the DEBUG log level.\nload_config: reload the broker config files from disk.\nsave_config: save the broker configuration to disk.\nshutdown: shutdown the broker.\n\nFor example the following set the broker log level to debug:\n\nusing Base64\nusing HTTP\n\nbasic_auth(str::String) = Base64.base64encode(str)\n\nadmin = \"admin\"\npassword = \"aaa\"\n\nauth = basic_auth(\"$admin:$password\")\nHTTP.get(\n    \"http://127.0.0.1:9000/admin/enable_debug\",\n    [\"Authorization\" => auth]\n)\n\n","category":"section"},{"location":"security/#Security","page":"Security","title":"Security","text":"End-to-end encryption is provided by Secure Web Socket (wss) and Transport Layer Security (tls).\n\nAuthentication and authorization are realized by using RSA and ECDSA keys (digital signature schemes).\n\nEach client component owns a private key, while the server/broker holds the corresponding public key.\n\nIn this document, the syntax $VARNAME indicates the environment variable VARNAME.","category":"section"},{"location":"security/#End-to-end-Encryption","page":"Security","title":"End-to-end Encryption","text":"The broker requires the following files in the directory \\$REMBUS_KEYSTORE:\n\nThe server certificate: rembus.crt\nThe server private key: rembus.key\n\nThe client component must have access to a CA bundle or the CA certificate of the authority that signed the broker’s certificate.\n\nThe environment variable HTTP_CA_BUNDLE may be used to specify this CA file.","category":"section"},{"location":"security/#Authentication","page":"Security","title":"Authentication","text":"To enable authentication, a previous exchange of a public key or a shared secret must be performed.\n\nIf the broker does not recognize the client’s key or secret, the connection will still be established, but the component will be treated as unauthenticated and will not have access to privileges reserved for authenticated components.\n\nFor a component named foobar, the authentication steps are:\n\nThe component sends a message declaring its name foobar.\nIf the file \\$BROKER_DB/keys/foobar exists, the broker replies with a random challenge.\nThe component computes a response:\nIf \\$HOME/.config/rembus/keys/foobar contains an RSA or ECDSA private key:\nCreate a SHA-256 digest of the string (challenge || \"foobar\").\nSign this digest with the private key.\nOtherwise, treat the file content as a shared secret and compute the SHA-256 digest of (challenge || shared_secret).\nThe component send the resulting digest (or signature) to the broker;\nThe broker verifies the response:\nif \\$HOME/.config/broker/keys/foobar contains an RSA or ECDSA public key:\nVerify that the signature matches (challenge || \"foobar\").  \nOtherwise verify that the digest equals the SHA-256 of (challenge || shared_secret).\nIf verification succeeds, the broker returns SUCCESS; otherwise, it returns ERROR and closes the connection.","category":"section"},{"location":"security/#Authorization","page":"Security","title":"Authorization","text":"By default, all topics are public, meaning accessible by any component.\n\nIf a topic is declared private, only authorized components may use the following methods:\n\npublish\nrpc\nexpose/unexpose\nsubscribe/unsubscribe\n\nTopic visibility can be changed by a component with the admin role:\n\nrb = connect(\"superuser\")\n\n# public -> private\nprivate_topic(rb, \"my_topic\")\n\n# private -> public\npublic_topic(rb, \"my_topic\")\n\nTo perform these actions, the admin role must be assigned to the component superuser, whose name must appear in the file \\$HOME/.config/broker/admins.json.\n\nMultiple components can be granted the admin role:\n\n# admis.json\n[\"superuser\", \"foobar\"]","category":"section"},{"location":"security/#Component-Registration","page":"Security","title":"Component Registration","text":"Authenticated components can be provisioned with the Rembus.register method.\n\nThis method generates an RSA or ECDSA key pair and distributes the public key to the broker.\n\nregister(component_name, pin; scheme=SIG_RSA)\n\ncomponent_name: The name of the component. The domain part defines its  tenant.\nExample: foo.xyz belongs to the tenant xyz, while foo (without a   domain) belongs to the default tenant (.).\npin: The tenant's secret PIN code.\nscheme: The signature scheme to use (optional):  can be:\nSIG_RSA - RSA digital signatures\nSIG_ECDSA - Elliptic Curve Digital Signature Algorithm\n\n","category":"section"},{"location":"macro_api/#Macro-based-API","page":"Macro-based API","title":"Macro-based API","text":"The supervised API uses the metaprogramming features of Julia and provides an high level interface that make easy to integrate distributed components.\n\nThe goal of this API is to make easy developing robust and fault-tolerant distributed applications.\n\nThe following macros comprise the API and enable Julia to be supercharged with the capabilities of a middleware for RPC and Pub/Sub messaging:\n\n@component\n@expose\n@unexpose\n@rpc\n@subscribe\n@unsubscribe\n@publish\n@reactive\n@unreactive\n@wait\n@inject","category":"section"},{"location":"macro_api/#@component","page":"Macro-based API","title":"@component","text":"A component needs to know the address of a broker, the transport protocol, the port and optionally it has to declare a persistent unique name for the component.\n\nThese settings are defined with a URL string:\n\ncomponent_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"\n\n@component component_url\n\n<protocol> is one of:\n\nws web socket\nwss secure web socket\ntcp tcp socket\ntls TLS over tcp socket\nzmq ZeroMQ socket\n\n<host> and <port> are the hostname/ip and the port of the listening broker.\n\n<cid> is the unique name of the component. If it is not defined create an anonymous component.\n\nFor example:\n\n@component \"ws://broker.org:8000/myclient\"\n\ndefines the component myclient that communicates with the broker hosted on broker.org, listening on port 8000 and accepting web socket connections.\n\nNOTE Rembus is \"lazy\": declaring a component does not open a connection to the broker. The connection will be opened when first needed.","category":"section"},{"location":"macro_api/#Default-component-URL-parameters","page":"Macro-based API","title":"Default component URL parameters","text":"The URL string may be simplified by using the enviroment variable REMBUS_BASE_URL.\n\nSetting for example REMBUS_BASE_URL=ws://localhost:8000 the above component_url may be simplified as:\n\n@component \"myclient\"","category":"section"},{"location":"macro_api/#@expose","page":"Macro-based API","title":"@expose","text":"Take a Julia function and exposes all of its the methods.\n\nfunction myservice(df::DataFrame)\n    ...\n    return another_dataframe\nend\n\nfunction myservice(map::Dict)\n    ...\n    return 0\nend\n\n@expose myservice\n\nThe exposed function will became available to RPC clients using the @rpc macro.","category":"section"},{"location":"macro_api/#@unexpose","page":"Macro-based API","title":"@unexpose","text":"Stop serving remote requests with @rpc requests.\n\n@unexpose myservice","category":"section"},{"location":"macro_api/#@rpc","page":"Macro-based API","title":"@rpc","text":"Request a remote method and wait for a response.\n\nresponse = @rpc myservice(Dict(\"name\"=>\"foo\", \"tickets\"=>3))\n\nThe arguments of the local function call myservice is transported to the remote site and myservice method expecting a Dict as argument is executed.\n\nThe return value of myservice is transported back to the RPC client calling site and @rpc returns.\n\nIf the remote method throws an Exception then the local RPC client throws an Exception reporting the reason of the remote error.","category":"section"},{"location":"macro_api/#@subscribe","page":"Macro-based API","title":"@subscribe","text":"Declare interest for messages published on a logical channel that usually is called topic.\n\nThe subscribed Julia methods are named as the topic of interest.\n\nfunction mytopic(x, y)\n    @info \"consuming x=$x and y=$y\"\nend\n\n@subscribe mytopic\n\nwait() # or until Ctrl-C \n\nBy default @subscribe will consume messages published after the component connect to the broker, messages sent previously are lost.\n\nFor receiving messages when the component was offline it is mandatory to set a component name and to declare interest in old messages with the option before_now:\n\n@component \"myname\"\n\n@subscribe mytopic before_now\n\n@wait # or until Ctrl-C\n\nNOTE By design messages are not persisted until a component declares\n\ninterest for a topic. In other words the persistence feature for a topic is enabled at the time of first subscription. If is important not to loose any message the rule is subscribe first and publish after.","category":"section"},{"location":"macro_api/#@unsubscribe","page":"Macro-based API","title":"@unsubscribe","text":"Stop the function to receive messages produced with @publish.\n\n@unsubscribe myservice","category":"section"},{"location":"macro_api/#@publish","page":"Macro-based API","title":"@publish","text":"Publishing a message is like calling a local function named as the pub/sub topic.\n\n@publish mytopic(1.2, 3.0)","category":"section"},{"location":"macro_api/#@reactive","page":"Macro-based API","title":"@reactive","text":"Enable the reception of published messages from subscribed topics.\n\n@reactive\n\nReactiveness is a property of a component and is applied to all subscribed topics.\n\nBy default a component starts with reactive mode enabled.","category":"section"},{"location":"macro_api/#@unreactive","page":"Macro-based API","title":"@unreactive","text":"Stop receiving published messages.\n\n@unreactive","category":"section"},{"location":"macro_api/#@wait","page":"Macro-based API","title":"@wait","text":"Needed for components that expose and/or subscribe methods. Wait forever for rpc requests or pub/sub messages.\n\nBy default @wait enable component reactiveness, see @reactive.","category":"section"},{"location":"macro_api/#@inject","page":"Macro-based API","title":"@inject","text":"@inject is handy when a state must be shared between the subscribed methods, the exposed methods and the application.\n\nWhen a state is injected two additional arguments are passed to the subscribed/exposed methods:\n\nthe first argument is the state value;\nthe second argument is the node handle;\n\nThe following example shows how to use a inject state:\n\nthe struct MyState manages the state;\nthe @inject macro binds the state object to the component;\nthe subscribed and the exposed method must declare as first argument the state object and as second argument the node handle;\n\nmutable struct MyState\n    counter::UInt\n    data::Dict()\n    MyState() = new(0, Dict())\nend\n\nmystate = MyState()\n\nfunction add_metric(mystate::MyState, rb::RBHandle, measure)\n    mystate.counter += 1 # count the received measures\n\n    try\n        indicator = measure[\"name\"]\n        mystate.data[indicator] = measure[\"value\"]\n    catch e\n        @error \"metrics: $e\"\n    end\nend\n\nfunction fetch_metrics(mystate)\n    return mystate.data\nend\n\n@component \"ingestor\"\n@inject mystate\n\n# declare interest to messages produced with\n# @publish add_metric(Dict(\"name\"=>\"pressure\", \"value\"=>1.5))\n@subscribe add_metric \n\n# implement a service that may be requested with\n# @rpc fetch_metrics()\n@expose fetch_metrics\n\n@wait\n\n","category":"section"},{"location":"brokerless/#Client-Server-architecture","page":"Client-Server","title":"Client-Server architecture","text":"It is possible to use Rembus protocol to setup a simple client-server architecture without a decoupling broker.\n\nIn Rembus what is called a \"client\" is a component that connects and a \"server is a component that accepts connections. Apart from this, the client and server are identical: the client can expose services and the server can call them.\n\nNOTE Without a broker a pub/sub is a one-to-one communication pattern: components publish messages that are received by the server but they are not broadcasted to anyone else.\n\nIn the below examples the server and the client plays the usual roles: the server exposes a service for handling RPC requests from the client.","category":"section"},{"location":"brokerless/#The-Server","page":"Client-Server","title":"The Server","text":"Below a minimal example of a component that exposes a service and accepts connections for others components and respond only to authenticated components:\n\nusing Rembus\n\nfunction my_service(x, y)\n    return x+y\nend\n\nrb = server()\nexpose(rb, my_service)\nwait(rb)","category":"section"},{"location":"brokerless/#The-Client","page":"Client-Server","title":"The Client","text":"On the calling side the client connects to the server and calls the service exposed by the server. The client can also publish messages to the server.\n\nusing Rembus\n\nrb = component(\"ws://localhost:8000/my_client\")\nresponse = rpc(rb, \"my_service\", x, y)\n\n","category":"section"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/#Environment-variables","page":"Configuration","title":"Environment variables","text":"A component is affected by the following environment variables.\n\nVariable Default Descr\nREMBUS_DIR $HOME/.config/rembus Rembus root directory\nREMBUS_BASE_URL ws://localhost:8000 Default base url when defining component with  a simple string instead of a complete url. @component \"myclient\" is equivalent to @component \"ws://localhost:8000/myclient\"\nREMBUS_TIMEOUT 5 Maximum number of seconds waiting for rpc responses\nREMBUS_ACK_TIMEOUT 5 Maximum number of seconds waiting for pub/sub ack messages\nREMBUS_CHALLENGE_TIMEOUT 5 Time interval after which the connection is closed if a challenge response is not received when connection_mode is authenticated\nREMBUS_RECONNECT_PERIOD 1 Reconnection retry period\nREMBUS_CACHE_SIZE 1000000 Max numbers of pub/sub messages cached in memory\nREMBUS_ARCHIVER_INTERVAL 60 Defines how often (in seconds) Pub/Sub messages are written to disk by the archiver.\nHTTP_CA_BUNDLE $REMBUS_DIR/ca/rembus-ca.crt CA certificate","category":"section"},{"location":"configuration/#Broker-only-environment-variables","page":"Configuration","title":"Broker only environment variables","text":"When a component is a broker the setup is affected also by the REMBUS_KEYSTORE variable that define the directory where are stored the private key and the server certificate needed for wss and tls secure connections.\n\nVariable Default Descr\nREMBUS_KEYSTORE $REMBUS_DIR/keystore Directory of broker/server certificate rembus.crt and broker/server secret key rembus.key","category":"section"},{"location":"configuration/#Broker-configuration-files","page":"Configuration","title":"Broker configuration files","text":"The broker name determines the directory where settings and component related data are stored.\n\nFor example, to set the name of the broker with the companion broker script use the optional name argument:\n\nbroker --name my_broker\n\nIn the following it is assumed the default broker name for the broker: in this case the directory $REMBUS_DIR/broker contains the broker configuration data and secret materials.\n\n> cd ~/.config/rembus/broker\n> tree .\n\n.\n├── admins.json\n├── bar.acks\n├── keys\n│   ├── bar.rsa.pem\n│   └── foo.ecdsa.pem\n├── messages\n    ├── 1345\n    ├── 345456\n    └── 867687\n├── settings.json\n├── tenants.json\n├── topic_auth.json\n├── twins\n│   ├── bar.json\n│   └── foo.json\n\n","category":"section"},{"location":"configuration/#Component-settings","page":"Configuration","title":"Component settings","text":"The behavoir of a component may be configured with the properties defined in the settings.json file. The values from settings.json take priority over environment variables values.\n\nThe following properties are supported (in parenthesis the corresponding environment variable):\n\narchiver_interval (REMBUS_ARCHIVER_INTERVAL): Interval (in seconds) for  persisting Pub/Sub messages to disk.\ncache_size (REMBUS_CACHE_SIZE): max numbers of pub/sub messages cached in memory;\nconnection_mode: \"authenticated\" or \"anonymous\" for components without name or  authentication credentials;\nack_timeout (REMBUS_ACK_TIMEOUT): timeout in seconds for pub/sub ack messages;\nchallenge_timeout (REMBUS_CHALLENGE_TIMEOUT): time interval after which the connection  is closed if a challenge response is not received. This feature holds only if  connection_mode is authenticated;\nrequest_timeout (REMBUS_TIMEOUT): maximum time in seconds for waiting a rpc response;\noverwrite_connection: If true a connecting component with the same name of an  already connected component connect successfully and the already connected component is  disconnected from the broker.\nreconnect_period (REMBUS_RECONNECT_PERIOD): reconnection retry period when connection is  down;\nstacktrace: When an exception occurs the error stack trace is logged if stacktrace is  true.\nzmq_ping_interval (REMBUS_ZMQ_PING_INTERVAL): ZMQ ping interval in seconds;\nws_ping_interval (REMBUS_WS_PING_INTERVAL): WebSocket ping interval in seconds;\n\n{\n    \"archiver_interval\": 60,\n    \"cache_size\": 1000000,\n    \"connection_mode\": \"anonymous\",\n    \"ack_timeout\": 2,\n    \"challenge_timeout\": 3,\n    \"request_timeout\": 5,\n    \"overwrite_connection\": false,\n    \"reconnect_period\": 1,\n    \"stacktrace\": false,\n    \"zmq_ping_interval\": 30,\n    \"ws_ping_interval\": 30\n}","category":"section"},{"location":"configuration/#Secrets-and-public-keys","page":"Configuration","title":"Secrets and public keys","text":"A file in the keys directory, named after the component name, contains the secret material used to authenticate the component.\n\nThis file may contain:\n\na RSA public key;\nan ECDSA public key;\na plaintext shared password string;\n\nTo create the RSA or ECDSA  key pairs and send the public key to the broker the register method may be employed.","category":"section"},{"location":"configuration/#Components-with-admin-privilege","page":"Configuration","title":"Components with admin privilege","text":"admins.json contains the list of components that have the admin role. The element of this list are component names.\n\n> cat admins.json\n[\"foo\", \"bar\"]\n\nA component with admin privilege may change the privateness level of topics and authorize other components to bind to private topics.\n\nSee private_topic, public_topic, authorize, unauthorize for details.","category":"section"},{"location":"configuration/#Component-configuration","page":"Configuration","title":"Component configuration","text":"The twins directory contains a configuration file for each component. The name of the file corresponds to the component name.\n\nthe content of the file is a JSON object with the following fields:\n\nexposers: the list of topics exposed by the component.\nsubscribers: a map where keys are topic names and values are the value of the  from subscribe option.\nmark: a counter value of the more recent received message.\n\nFor example, the file twins/mycomponent.json is a configuration for the component mycomponent. Such component exposes the RPC service myservice and subscribes to the topic mytopic with a from value of 3600.0 seconds.\n\n> cat twins/mycomponent.json\n{\n    \"exposers\":[\"myservice\"],\n    \"subscribers\":{\"mytopic\":3600.0},\n    \"mark\":1234\n}","category":"section"},{"location":"configuration/#Private-topics","page":"Configuration","title":"Private topics","text":"topic_auth.json is a map with topic as keywords and an array of component names as values.\n\nFor example the following file defines the topic foo as private and only the components myconsumer and myproducer are allowed to bind to it.\n\n> cat topic_auth.json\n{\n    \"foo\":[\"myconsumer\",\"myproducer\"]\n}","category":"section"},{"location":"configuration/#Multi-Tenancy","page":"Configuration","title":"Multi-Tenancy","text":"The multi-tenancy feature enables the logical isolation of components by assigning them to specific tenants.\n\nCommunication is restricted: only components belonging to the same tenant can interact with each other.\n\nA component's tenant is determined by the domain part of its name. For instance, the component foo.org belongs to the org tenant. Components without a domain (e.g., my_component) are automatically assigned to the default tenant, represented by a single dot (.).\n\nTo register components, each tenant must possess a unique secret PIN. This PIN is an 8-character hexadecimal string, configured within the tenants.json file.\n\ntenants.json File Example (Multi-Tenant Configuration):\n\n{\n  \"org\": \"deadbeef\",\n  \"com\": \"482dc7eb\"\n}\n\nFor single-tenant Rembus setups, the tenants.json file should contain only one PIN value, designated for the default tenant. This PIN will be used for all component registrations.\n\n{\n  \".\": \"deadbeef\"\n}","category":"section"},{"location":"configuration/#Published-messages-database","page":"Configuration","title":"Published messages database","text":"the files in messages store all the published messages received by the broker. The messages are saved periodically and at broker shutdown.\n\n","category":"section"},{"location":"fault_tolerance/#Fault-tolerance-features","page":"Fault-tolerance features","title":"Fault-tolerance features","text":"Beside struggling to provide a simple and lean API one of the main points of Rembus is its ability to be fault-tolerant respect to networks and application failures.\n\nThe Macro-based API and the component method provide an automatic reconnection policy in case of network faults and try at the best to guarantee message delivery when faults happen.\n\nThis mean that the following RPC service will run forever and it will reconnect automatically in case of network failures or broker unavailability.\n\nusing Rembus\n\n@component \"mycomponent\"\n\nfunction myservice(input::DataFrame)\n    # run your super-cool logic and get back the result\n    output_df = my_logic(input)\n    return output_df\nend\n\n@expose myservice\n\n@wait\n\nFault-tolerance holds equally for publish/subscribe setups: in case of connection lost the subscriber retries to reconnect to the broker until the connection will be up again.   \n\nIf the subscription use the before_now option then messages published whereas the component was offline are delivered ordered by time of publishing when the component get online again.\n\nusing Rembus\n\n@component \"consumer\"\n\nfunction mytopic(input::DataFrame)\n    # consume the dataframe posted to mytopic topic\nend\n\n@subscribe mytopic before_now\n\n@wait\n\n","category":"section"},{"location":"#Rembus","page":"Home","title":"Rembus","text":"Rembus is a Julia package designed for building distributed applications using both Publish/Subscribe (Pub/Sub) and Remote Procedure Call (RPC) communication patterns. \n\nA key distinguishing feature of Rembus is its highly flexible role system, allowing a single application to act as a client, server, publisher, subscriber, and even a message broker concurrently.\n\nThis unique capability enables the implementation of a wide range of distributed architectures.\n\nKey Features:\n\nSupport multiple transport protocol: WebSocket, TCP, and ZeroMQ.\nEfficient CBOR encoding for primitive types.\nOptimized Arrow Table Format for encodings DataFrames.\n\nApplication Roles:\n\nAn application utilizing Rembus can assume one or more of the following roles:\n\nRPC Client (Requestor): Initiates requests for services from other components.\nRPC Server (Exposer): Provides and executes services in response to requests.\nPub/Sub Publisher: Produces and disseminates messages to interested subscribers.\nPub/Sub Subscriber: Consumes messages published on specific topics.\nBroker: Routes messages between connected components, potentially across different transport protocols.\nBroker and Component: Combines the routing capabilities of a broker with the application logic of a component.\nServer: Accepts connections from clients but does not route messages between them in the same way a broker does.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Rembus\")","category":"section"},{"location":"#Broker","page":"Home","title":"Broker","text":"A Rembus Broker acts as a central message router, facilitating communication between components. Importantly, a Broker can bridge components using different transport protocols (e.g., a ZeroMQ component can communicate with a WebSocket component).\n\nStarting a basic WebSocket Broker:\n\nusing Rembus\n\ncomponent() # Starts a WebSocket server listening on port 8000\n\nThe connection point for this broker is ws://host:8000.\n\nA Broker can also function as a Component, connecting to another broker while simultaneously acting as a local broker:\n\nusing Rembus\nrb = component(\"ws://myhost:8000/mynode\", ws=9000)\n\nHere, the mynode component connects to the broker at myhost:8000 and also acts as a broker, accepting WebSocket connections on port 9000 and routing messages between its connected components.","category":"section"},{"location":"#Component","page":"Home","title":"Component","text":"A Rembus Component is a process that embodies one or more of the communication roles (Publisher, Subscriber, Requestor, Exposer). To connect to a broker, a component uses a URL with the broker's connection point and a unique component identifier:\n\ncomponent_url = \"[<protocol>://][<host>][:<port>/][<cid>]\"\n\nWhere <protocol> is one of ws, wss, tcp, tls, or zmq. <host> and <port> specify the broker's address, and <cid> is the component's unique name (optional for anonymous components).\n\nExample connecting a named component:\n\nrb = component(\"ws://host:8000/my_component\")\n\nA Component can also act as a Broker:\n\npub = component(\"ws://host:8000/my_pub\", ws=9000)\n\nThe my_pub component communicates with the broker at host:8000 and simultaneously acts as a WebSocket broker on port 9000 for other components..\n\nTypes of Components:\n\nAnonymous: Assumes a random, ephemeral identity on each connection. Useful when message origin tracing isn't required, for subscribers uninterested in offline messages, and for prototyping.\nNamed: Possesses a unique, persistent name, enabling it to receive messages published while offline.\nAuthenticated: A named component with cryptographic credentials (private key or shared secret) to prove its identity, allowing access to private Pub/Sub topics and RPC methods.","category":"section"},{"location":"#Server","page":"Home","title":"Server","text":"Rembus simplifies the client-server architecture with a dedicated server API for creating components that accept client connections without acting as general-purpose message routers:\n\nrb = server(ws=9876)\n\nA server can expose RPC services and subscribe to Pub/Sub topics (typical server roles) but can also publish messages or request RPC services from its connected clients.","category":"section"},{"location":"#A-Simple-Broker-Script","page":"Home","title":"A Simple Broker Script","text":"#!/bin/bash\n#=\nSDIR=$( dirname -- \"${BASH_SOURCE[0]}\" )\nBINDIR=$( cd -- $SDIR &> /dev/null && pwd )\nexec julia -t auto --color=no -e \"include(popfirst!(ARGS))\" \\\n --project=$BINDIR/.. --startup-file=no \"${BASH_SOURCE[0]}\" \"$@\"\n=#\nusing Rembus\nRembus.brokerd()\n\nThis script starts a Rembus broker with a default WebSocket server on port 8000. Use command-line arguments (e.g., ./broker -t 8001 -z 8002) to enable TCP and ZeroMQ transports.\n\nshell> ./broker\nusage: broker [-n NAME] [-x] [-s] [-a] [-p HTTP] [-m PROMETHEUS]\n              [-w WS] [-t TCP] [-z ZMQ] [-r POLICY] [-d] [-i] [-h]\n\noptional arguments:\n  -n, --name NAME       broker name (default: \"broker\")\n  -x, --reset           factory reset, clean up broker configuration\n  -s, --secure          accept wss and tls connections\n  -a, --authenticated   only authenticated components allowed\n  -p, --http HTTP       accept HTTP clients on port HTTP (type:\n                        UInt16)\n  -m, --prometheus PROMETHEUS\n                        prometheus exposer port (type: UInt16)\n  -w, --ws WS           accept WebSocket clients on port WS (type:\n                        UInt16)\n  -t, --tcp TCP         accept tcp clients on port TCP (type: UInt16)\n  -z, --zmq ZMQ         accept zmq clients on port ZMQ (type: UInt16)\n  -r, --policy POLICY   set the broker routing policy: first_up,\n                        round_robin, less_busy (default: \"first_up\")\n  -d, --debug           enable debug logs\n  -i, --info            enable info logs\n  -h, --help            show this help message and exit\n\nSee Configuration for customizing the runtime setting.  ","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"\n\n","category":"section"},{"location":"#Rembus.RembusError","page":"Home","title":"Rembus.RembusError","text":"struct RembusError <: Rembus.RembusException\n\nGeneric Rembus error.\n\nFields\n\ncode::UInt8: error code\ntopic::Union{Nothing, String}: topic name if available\nreason::Union{Nothing, String}: detailed error message\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RembusTimeout","page":"Home","title":"Rembus.RembusTimeout","text":"struct RembusTimeout{T} <: Rembus.RembusException\n\nException thrown when a response is not received before the request timeout expires.\n\nFields\n\nmsg::Any: request message\nstatus::UInt8\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodException","page":"Home","title":"Rembus.RpcMethodException","text":"struct RpcMethodException <: Rembus.RembusException\n\nThrown when a RPC method throws an exception.\n\nFields\n\ntopic::String: service name\nreason::String: remote exception description\n\nExample\n\nA component exposes a method that expect a string argument.\n\n@expose foo(name::AbstractString) = \"hello \" * name\n\nA RPC client invoke the method with an integer argument.\n\ntry\n    @rpc foo(1)\ncatch e\n    @error e.reason\nend\n\nThe result is an exception:\n\n┌ Error: MethodError: no method matching foo(::UInt64)\n│\n│ Closest candidates are:\n│   foo(!Matched::AbstractString)\n│    @ Main REPL[2]:1\n└ @ Main REPL\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodLoopback","page":"Home","title":"Rembus.RpcMethodLoopback","text":"struct RpcMethodLoopback <: Rembus.RembusException\n\nThrown when a RPC request would invoke a locally exposed method.\n\nFields\n\ntopic::String: service name\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodNotFound","page":"Home","title":"Rembus.RpcMethodNotFound","text":"struct RpcMethodNotFound <: Rembus.RembusException\n\nException thrown from a rpc request when the called method is unknown.\n\nFields\n\ntopic::String: service name\n\nExample\n\nAn RPC Client request a method that does not exist.\n\n@rpc coolservice()\n\nThe result is an exception:\n\nERROR: Rembus.RpcMethodNotFound(\"rembus\", \"coolservice\")\nStacktrace:\n...\n\n\n\n\n\n","category":"type"},{"location":"#Rembus.RpcMethodUnavailable","page":"Home","title":"Rembus.RpcMethodUnavailable","text":"struct RpcMethodUnavailable <: Rembus.RembusException\n\nThrown when a RPC method is unavailable.\n\nA method is considered unavailable when some component that exposed the method is currently disconnected from the broker.\n\nFields\n\ntopic::String: service name\n\n\n\n\n\n","category":"type"},{"location":"#Base.close-Tuple{Rembus.Twin}","page":"Home","title":"Base.close","text":"close(rb::Rembus.Twin)\n\n\nClose the connection and terminate the component.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isopen-Tuple{Rembus.Twin}","page":"Home","title":"Base.isopen","text":"isopen(rb::Rembus.Twin) -> Bool\n\n\nCheck if the component is connected to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Base.wait-Tuple{Rembus.Twin}","page":"Home","title":"Base.wait","text":"wait(rb::Rembus.Twin)\n\n\nWait for RPC requests and Pub/Sub messages.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.authorize-Tuple{Rembus.Twin, AbstractString, AbstractString}","page":"Home","title":"Rembus.authorize","text":"function authorize(rb, client::AbstractString, topic::AbstractString)\n\nAuthorize the client component to use the private topic.\n\nThe component must have the admin role for granting topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.broker","page":"Home","title":"Rembus.broker","text":"broker(; <keyword arguments>)\n\nStart a broker node and return a handle for interacting with it.\n\nThe broker acts as a central node to manage routing of RPC requests and Pub/Sub messages between nodes.\n\nIt supports multiple communication protocols (WebSocket, TCP, and ZMQ) and allows for customizable security, authentication, and routing policies.\n\nKeyword arguments\n\nname::AbstractString=\"broker\": The unique identifier for the broker supervisor process.\nws=nothing: The WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: The TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: The ZMQ Router listening port. Set to nothing to disable.\nprometheus=nothing: The Prometheus port for scraping monitoring metrics. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\npolicy::String=\"first_up\": The routing policy used when topics are served by multiple  nodes. Possible options include:\n\"first_up\": Selects the first connected node from the list of nodes exposing the RPC method.\n\"round_robin\": Distributes requests evenly across nodes in a round-robin fashion.\n\"less_busy\": Chooses the node with fewer outstanding requests.\nDefault Behavior\nIf ws, tcp, and zmq are all set to nothing, the broker will default to listening   for WebSocket connections on port 8000.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.component","page":"Home","title":"Rembus.component","text":"component(url::AbstractString; <keyword arguments>)\n\nStart a component node and return a handle for interacting with it.\n\nIn case of connection lost the underlying supervision logic attempts to reconnect to the broker until it succeed.\n\nThe url argument specifies the connection details for the component. For example, the URL ws://127.0.0.1:8000/foo specifies:\n\nProtocol: ws (WebSocket). Other supported protocols: wss, tcp, tls, zmq.\nAddress: 127.0.0.1 (localhost).\nPort: 8000.\nComponent Name: foo.\n\nAnonymous connections omit the path part of the URL.\n\nIf not specified, Rembus considers the above values as the default values.\n\nThis means the URL ws://127.0.0.1:8000/foo is equivalent to simply foo.\n\nAdditionally, a component may listen for incoming connections on configured ports, enabling it to act as a broker. These ports are specified using keyword arguments.\n\nKeyword Arguments\n\nname=missing: Unique string identifier for the component's supervisor process. Defaults to the path part of the url argument if missing.\nws=nothing: WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: ZMQ Router listening port. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\npolicy::String=\"first_up\": The routing policy used when topics are served by multiple  nodes. Options:\n\"first_up\": Selects the first connected node from the list of nodes exposing the RPC method.\n\"round_robin\": Distributes requests evenly across nodes in a round-robin fashion.\n\"less_busy\": Chooses the node with fewer outstanding requests.\nenc=Rembus.CBOR: wire message format for sending messages  Set to Rembus.JSON for JSON-RPC-2.0 text encoding.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.component-2","page":"Home","title":"Rembus.component","text":"component(urls::Vector)\n\nStart a component that connects to a pool of nodes defined by the urls array.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.connect-Tuple{AbstractString}","page":"Home","title":"Rembus.connect","text":"connect(url::AbstractString; enc) -> Rembus.Twin\n\n\nConnect to the remote endpoint defined by url.\n\nA disconnection from the remote endpoint will not trigger automatic reconnection.\n\nExample\n\nrb = connect(\"ws://127.0.0.1:8000/mycomponent\")\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.do_connect-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.do_connect","text":"do_connect(twin::Twin)\n\nConnect to the endpoint declared with REMBUS_BASE_URL env variable.\n\nREMBUS_BASE_URL default to ws://127.0.0.1:8000\n\nA component is considered anonymous when a different and random UUID is used as component identifier each time the application connect to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.expose-Tuple{Rembus.Twin, AbstractString, Function}","page":"Home","title":"Rembus.expose","text":"expose(rb, topic::AbstractString, fn::Function)\nexpose(rb, fn::Function)\n\nExpose the methods of function fn to be executed by rpc clients using topic as RPC method name.\n\nIf the topic argument is omitted the function name equals to the RPC method name.\n\nfn returns the RPC response.\n\nExpose the methods of function fn to be invoked by RPC clients, using topic as the RPC method name.\n\nIf the topic argument is omitted, the function name is used as the RPC method name.\n\nfn is expected to return the RPC response. Any exceptions thrown by fn are caught and returned as an RPC exception.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.get_private_topics-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.get_private_topics","text":"get_private_topics(rb)\n\nReturn a dictionary mapping private topics to their lists of authorized components.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.ifdown_block-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.ifdown_block","text":"ifdown_block(rb::Rembus.Twin)\n\n\nBlock rpc and publish calls until the twin is connected to the broker.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.inject","page":"Home","title":"Rembus.inject","text":"inject(rb, ctx)\n\nBind a ctx context to the rb component.\n\nWhen a ctx context is bound, the method signatures of subscribed and exposed functions change as follows:\n\nthe first argument is the ctx context.\nthe second argument is the rb component.\nThe remaining arguments correspond to the RPC request's arguments.\n\nThe ctx is useful for maintaining local state contextualized to the rb component.\n\nExample\n\nusing Rembus\n\n# keep the number of processed messages\nmutable struct Context\n    msgcount::UInt\nend\n\nfunction topic(context::Context, rb, arg1, arg2)\n    context.msgcount += 1\n    some_logic(arg1, arg2)\nend\n\nctx = Context(0)\nrb = component(\"myname\")\nsubscribe(rb, topic)\ninject(rb, ctx)\n\nIn this example, when a message is published:\n\npublish(rb, \"topic\", arg1, arg2)\n\nThe invoked method will receive the context and component as the first two arguments:\n\nfoo(container, rb, arg2, arg2)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.isauthenticated-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.isauthenticated","text":"isauthenticated(rb)\n\nReturn true if the component is authenticated.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.jsonrpc_request-Tuple{Any, Dict, Any, Any}","page":"Home","title":"Rembus.jsonrpc_request","text":"jsonrpc_request(pkt::Dict, msg_id, params) -> RembusMsg\n\nParse a JSON-RPC request and return the appropriate RembusMsg subtype.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.private_topic-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.private_topic","text":"private_topic(rb, topic::AbstractString)\n\nSet the specified topic to private.\n\nThe component must have the admin role to change the privacy level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.public_topic-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.public_topic","text":"public_topic(rb, topic::AbstractString)\n\nSet the specified topic to public.\n\nThe component must have the admin role to change the privacy level.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.publish-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.publish","text":"publish(rb, topic::AbstractString, data...; qos=Rembus.QOS0)\n\nPublish one or more data values to a topic.\n\nEach element in data is passed as an argument to the remote method subscribed to topic.\n\nThe data arguments may be of any type. For interoperability across components implemented in different languages, the values should be either DataFrames or primitive types that are CBOR-encodable (see RFC 8949).\n\nThe keyword argument qos specifies the quality of service (QoS) for message delivery:\n\nRembus.QOS0 (default): At most once delivery. A message may be delivered zero or one time.\nRembus.QOS1: At least once delivery. A message is delivered one or more times.\nRembus.QOS2: Exactly once delivery. A message is delivered once and only once.\n\nExamples\n\nIf the subscriber is a method that expects two arguments:\n\nmytopic(x, y) = ...  # do something with x and y\n\nYou can publish a message with two data values::\n\nrb = component(\"myname\")\npublish(rb, \"mytopic\", 1, 2)\n\nIf the remote subscribed method has no arguments, publish without data:\n\npublish(rb, \"mytopic\")\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.put-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.put","text":"put(rb, topic::AbstractString, data...; qos=Rembus.QOS0)\n\nPublish one or more data values to a channel identified by topic, which is automatically prefixed with the component name.\n\nEach element in data is passed as an argument to the remote method subscribed to topic.\n\nThe data arguments may be of any type. For interoperability across components implemented in different languages, the values should be either DataFrames or primitive types that are CBOR-encodable (see RFC 8949).\n\nThe keyword argument qos specifies the quality of service (QoS) for message delivery:\n\nRembus.QOS0 (default): At most once delivery. A message may be delivered zero or one time.\nRembus.QOS1: At least once delivery. A message is delivered one or more times.\nRembus.QOS2: Exactly once delivery. A message is delivered once and only once.\n\nExamples\n\nrb = component(\"myname\")\nput(rb, \"mytopic\", 1, 2)\n\nThis publishes the values 1 and 2 to the topic myname/mytopic.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.reactive","page":"Home","title":"Rembus.reactive","text":"reactive(rb, from::Union{Real,Period,Dates.CompoundPeriod}=Day(1))\n\nEnable the reception of published messages for topics to which the node is subscribed via subscribe.\n\nThe from argument specifies the starting point in time from which messages published while the component was offline will be delivered upon reconnection.\n\nThis value applies to all subscribed topics but can be overridden by the from argument in the subscribe method for a specific topic — though only to define narrower time ranges.\n\nPossible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.\n\nExample\n\nrb = component(\"myname\")\nsubscribe(rb, \"mytopic1\", Rembus.Now)\nsubscribe(rb, \"mytopic2\", Rembus.LastReceived)\nsubscribe(rb, \"mytopic3\", Hour(1))\n\nreactive(rb, Day(1))\n\nIn this example:\n\nmytopic1 will receive messages starting from now.\nmytopic2 will receive messages published within the last day, even if subscribe()    uses Rembus.LastReceived.\nmytopic3 will receive messages published within the last hour.\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.register-Tuple{AbstractString, AbstractString}","page":"Home","title":"Rembus.register","text":"register(\n    cid::AbstractString,\n    pin::AbstractString;\n    scheme::UInt8\n)\n\nRegister the component with name cid.\n\nTo register a component a single pin or a set of tenants must be configured in the tenants.json file.\n\nThe pin shared secret is a 8 hex digits string (for example \"deedbeef\").\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout!-Tuple{Rembus.Twin, Real}","page":"Home","title":"Rembus.request_timeout!","text":"request_timeout!(rb, value::Real)\n\nSet the request timeout value for the component rb.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.request_timeout-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.request_timeout","text":"request_timeout(rb)\n\nGet the request timeout value for the component rb.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rid-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.rid","text":"rid(rb::Rembus.Twin) -> String\n\n\nReturn the identifier of the component (Rembus IDentifier).\n\nrb = component(\"ws://myhost.org:8000/myname\")\nrid(rb) === \"myname\"\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.rpc-Tuple{Rembus.Twin, AbstractString, Vararg{Any}}","page":"Home","title":"Rembus.rpc","text":"rpc(rb, service::AbstractString, data...)\n\nMake a request for a remote service method using Vararg data values as method arguments.\n\nReturn a value or throw an error if a request timeout occurs or the remotely invoked method throws an exception.\n\nExample\n\nrb = component(\"myclient\")\n# invoke mysum(1, 2) on the remote site\nresult = rpc(rb, \"mysum\", 1, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.send_data_at_rest-Tuple{Rembus.Twin, Float64, Rembus.FileStore}","page":"Home","title":"Rembus.send_data_at_rest","text":"send_data_at_rest(twin::Rembus.Twin, max_period::Float64, con::DuckDB.DB\n\nSend persisted and cached messages.\n\nmax_period is a time barrier set by the reactive command.\n\nValid time period for sending old messages: [min(twin.topic.msg_from, max_period), now_ts]\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.server-Tuple{}","page":"Home","title":"Rembus.server","text":"server(; <keyword arguments>)\n\nStart a server node and return a handle for interacting with it.\n\nThe server accepts connection from client nodes.\n\nIt supports multiple communication protocols (WebSocket, TCP, and ZMQ) and allows for customizable security and authentication.\n\nKeyword arguments\n\nname::AbstractString=\"broker\": The unique identifier for the server supervisor process.\nws=nothing: The WebSocket (ws/wss) listening port. Set to nothing to disable.\ntcp=nothing: The TCP (tcp/tls) listening port. Set to nothing to disable.\nzmq=nothing: The ZMQ Router listening port. Set to nothing to disable.\nprometheus=nothing: The Prometheus port for scraping monitoring metrics. Set to nothing to disable.\nsecure=false: If true, enables WSS (WebSocket Secure) and TLS (Transport Layer Security) protocols for encrypted connections.\nauthenticated=false: If true, only allows connections from named and authenticated  nodes.\n\nDefault Behavior\n\nIf ws, tcp, and zmq are all set to nothing, the broker will default to listening for WebSocket connections on port 8000.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.start_broker-Tuple{Any}","page":"Home","title":"Rembus.start_broker","text":"start_broker(;\n    wait=true,\n    secure=nothing,\n    ws=nothing,\n    tcp=nothing,\n    zmq=nothing,\n    http=nothing,\n    prometheus=nothing,\n    name=\"broker\",\n    authenticated=false,\n    reset=nothing,\n    plugin=nothing,\n    context=nothing\n)\n\nStart the node.\n\nReturn immediately when wait is false, otherwise blocks until shutdown is requested.\n\nOverwrite command line arguments if args is not empty.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.subscribe","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb, fn::Function, from=Rembus.Now)\n\nSubscribe to messages published to a topic and register a callback function fn to handle incoming messages.\n\nIf the topic argument is omitted, the function name must be equal to the topic name.\n\nThe from (default=Rembus.Now) argument defines the starting point in time from which messages published while the component was offline will be sent upon reconnection. Possible from values:\n\nRembus.Now: Equivalent to 0.0, ignores old messages, and starts receiving only new messages from now.\nRembus.LastReceived: Receives all messages published since the last disconnection.\nn::Float64: Receives messages published within the last n seconds.\nDates.CompoundPeriod: Defines a custom period using a CompoundPeriod value.\n\nTo enable the reception of published messages, the reactive function must be called.\n\nExample\n\nrb = component(\"myname\")\n\n# Define a callback function for the \"mytopic\" topic\nfunction mytopic(data)\n    println(\"Received: \", data)\nend\n\n# Subscribe to \"mytopic\", receiving only new messages from now\nsubscribe(rb, mytopic, from=Rembus.Now)\nreactive(rb)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.subscribe-2","page":"Home","title":"Rembus.subscribe","text":"subscribe(rb, topic::AbstractString, fn::Function, from=Rembus.Now)\n\n\n\n\n\n","category":"function"},{"location":"#Rembus.unauthorize-Tuple{Rembus.Twin, AbstractString, AbstractString}","page":"Home","title":"Rembus.unauthorize","text":"function unauthorize(rb, client::AbstractString, topic::AbstractString)\n\nRevoke authorization to the client component for use of the private topic.\n\nThe component must have the admin role for revoking topic accessibility.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb, service::AbstractString)\n\nStop servicing RPC requests targeting service.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unexpose-Tuple{Rembus.Twin, Function}","page":"Home","title":"Rembus.unexpose","text":"unexpose(rb, fn::Function)\n\nStop servicing RPC requests targeting fn function.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unreactive-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.unreactive","text":"unreactive(rb)\n\nStops the delivery of published messages to the rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unregister-Tuple{Rembus.Twin}","page":"Home","title":"Rembus.unregister","text":"unregister(twin)\n\nUnregister the connected component.\n\nOnly a connected and authenticated component may execute the unregister command.\n\nusing Rembus\n\ntwin = connect(\"authenticated_component\")\nRembus.unregister(twin)\nclose(twin)\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.Twin, AbstractString}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb, topic::AbstractString)\n\nStops delivering messages published on the specified topic to the rb component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.unsubscribe-Tuple{Rembus.Twin, Function}","page":"Home","title":"Rembus.unsubscribe","text":"unsubscribe(rb, fn::Function)\n\nStops delivering messages to the specified fn function.\n\n\n\n\n\n","category":"method"},{"location":"#Visor.shutdown-Tuple{Rembus.Twin}","page":"Home","title":"Visor.shutdown","text":"shutdown(rb::Rembus.Twin)\n\n\nClose the connection and terminate the component.\n\n\n\n\n\n","category":"method"},{"location":"#Rembus.@component-Tuple{Any}","page":"Home","title":"Rembus.@component","text":"@component \"url\"\n\nSet the name of the component and the protocol for connecting to the broker.\n\nurl may be:\n\n\"myname\": use $REMBUS_BASE_URL for connection parameters\n\"tcp://host:port/myname\": tcp connection\n\"ws://host:port/myname\": web socket connection\n\"zmq://host:port/myname\": ZeroMQ connection\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Expr}","page":"Home","title":"Rembus.@expose","text":"@expose function fn(arg1,...)\n    ...\nend\n\nExpose the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@expose-Tuple{Symbol}","page":"Home","title":"Rembus.@expose","text":"@expose fn\n\nExpose all the methods of the function fn.\n\nExample\n\nExpose the function mycalc that implements a service that may accept two numbers or a string and number:\n\nmycalc(x::Number, y::Number) = x+y\nmycalc(x::String, y::Number) = length(x)*y\n\n@expose mycalc\n\nCall mycal service using the correct types of arguments:\n\n# ok\njulia> response = @rpc mycalc(1,2)\n0x0000000000000003\n\n# ok\njulia> response = @rpc mycalc(\"hello\",2.0)\n10.0\n\nIf the RPC client call mycalc with the argument's type that do not respect the signatures of the exposed service then it throws RpcMethodException\n\njulia> response = @rpc mycalc(\"hello\",\"world\")\nERROR: RpcMethodException(\"rembus\", \"mycalc\", \"MethodError: no method matching mycalc(::String, ::String) ...\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@inject-Tuple{Any}","page":"Home","title":"Rembus.@inject","text":" @inject container\n\nBinds a container object, which is passed as the first argument to subscribed component functions.\n\nSee inject for more details.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@publish","page":"Home","title":"Rembus.@publish","text":"@publish topic(arg1,arg2,...)\n\nPublish a message to topic logic channel.\n\nThe function topic(arg1,arg2,...) will be called on each connected component subscribed to topic.\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\nSubscriber\n\nfunction foo(name, value)\n    println(\"do something with $name=$value\")\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@reactive","page":"Home","title":"Rembus.@reactive","text":"@reactive\n\nThe subscribed methods start to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@rpc-Tuple{Any}","page":"Home","title":"Rembus.@rpc","text":"@rpc service(arg1,...)\n\nCall the remote service method and return its outcome.\n\nThe outcome may be the a return value or a RpcMethodException if the remote throws an exception.\n\nThe service method must match the signature of an exposed remote service method.\n\nComponents may subscribe to service for receiving the service request.\n\nExposer\n\nfunction mymethod(x, y)\n    return evaluate(x,y)\nend\n\n@expose mymethod\nsupervise()\n\nRPC client\n\nresponse = @rpc mymethod(x,y)\n\nSubscriber\n\nfunction service(x, y)\n    ...\nend\n\n@subscribe service\n@reactive\n\nsupervise()\n\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe","page":"Home","title":"Rembus.@subscribe","text":"@subscribe topic [mode]\n\nSetup a subscription to topic logic channel to handle messages from @publish or @rpc.\n\nmode values`:\n\nfrom_now (default): receive messages published from now.\nbefore_now: receive messages published when the component was offline.\n\nMessages starts to be delivered to topic when reactivity is enabled with @reactive macro.\n\nSubscriber\n\nfunction foo(arg1, arg2)\n    ...\nend\n\n@subscribe foo\n@reactive\n\nsupervise()\n\nPublisher\n\n@publish foo(\"gfr\", 54.2)\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@subscribe-2","page":"Home","title":"Rembus.@subscribe","text":"@subscribe function fn(args...)\n    ...\nend [mode]\n\nSubscribe the function expression.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unexpose-Tuple{Any}","page":"Home","title":"Rembus.@unexpose","text":"@unexpose fn\n\nThe methods of fn function is no more available to rpc clients.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unreactive-Tuple{}","page":"Home","title":"Rembus.@unreactive","text":"@unreactive\n\nThe subscribed methods stop to handle published messages.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@unsubscribe-Tuple{Any}","page":"Home","title":"Rembus.@unsubscribe","text":"@unsubscribe mytopic\n\nmytopic's methods stop to handle messages published to topic mytopic.\n\n\n\n\n\n","category":"macro"},{"location":"#Rembus.@wait-Tuple{}","page":"Home","title":"Rembus.@wait","text":"@wait\n\nBlock forever waiting for Ctrl-C/InterruptException or root supervisor shutdown.\n\n\n\n\n\n","category":"macro"}]
}
